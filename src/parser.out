Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> DECLARATION LBRACE declarations RBRACE INSTRUCTION LBRACE instructions RBRACE
Rule 2     declarations -> declarations declaration
Rule 3     declarations -> declaration
Rule 4     declarations -> empty
Rule 5     declaration -> type_declaration
Rule 6     declaration -> const_declaration
Rule 7     type_declaration -> type var_list SEMICOL
Rule 8     var_list -> var_list COMMA var_item
Rule 9     var_list -> var_item
Rule 10    var_item -> IDF
Rule 11    var_item -> IDF LBRACKET INTEGER RBRACKET
Rule 12    var_item -> IDF EQUALS const_value
Rule 13    type -> TYPE_INTEGER
Rule 14    type -> TYPE_FLOAT
Rule 15    type -> TYPE_CHAR
Rule 16    const_declaration -> CONST type IDF EQUALS const_value SEMICOL
Rule 17    const_value -> INTEGER
Rule 18    const_value -> FLOAT
Rule 19    const_value -> CHAR
Rule 20    instructions -> instructions instruction
Rule 21    instructions -> instruction
Rule 22    instructions -> empty
Rule 23    instruction -> assignment SEMICOL
Rule 24    instruction -> array_assignment SEMICOL
Rule 25    instruction -> if_statement
Rule 26    instruction -> for_loop
Rule 27    instruction -> io_statement SEMICOL
Rule 28    assignment -> IDF EQUALS expression
Rule 29    array_assignment -> IDF LBRACKET expression RBRACKET EQUALS expression
Rule 30    expression -> expression2 PLUS expression2
Rule 31    expression -> expression2 MINUS expression2
Rule 32    expression -> expression2 MULTIPLY expression2
Rule 33    expression -> expression2 DIVIDE expression2
Rule 34    expression -> LPAREN expression2 RPAREN
Rule 35    expression -> IDF
Rule 36    expression -> IDF LBRACKET expression2 RBRACKET
Rule 37    expression -> INTEGER
Rule 38    expression -> FLOAT
Rule 39    expression -> CHAR
Rule 40    expression2 -> expression2 PLUS expression2
Rule 41    expression2 -> expression2 MINUS expression2
Rule 42    expression2 -> expression2 MULTIPLY expression2
Rule 43    expression2 -> expression2 DIVIDE expression2
Rule 44    expression2 -> LPAREN expression2 RPAREN
Rule 45    expression2 -> IDF
Rule 46    expression2 -> IDF LBRACKET expression2 RBRACKET
Rule 47    expression2 -> INTEGER
Rule 48    expression2 -> FLOAT
Rule 49    if_statement -> IF LPAREN condition RPAREN LBRACE instructions RBRACE
Rule 50    if_statement -> IF LPAREN condition RPAREN LBRACE instructions RBRACE ELSE LBRACE instructions RBRACE
Rule 51    for_loop -> FOR LPAREN assignment COLOM for_pas COLOM for_condition RPAREN LBRACE instructions RBRACE
Rule 52    for_pas -> IDF
Rule 53    for_pas -> INTEGER
Rule 54    for_condition -> IDF
Rule 55    for_condition -> INTEGER
Rule 56    condition -> expression comparison_op expression
Rule 57    condition -> condition AND condition
Rule 58    condition -> condition OR condition
Rule 59    condition -> NOT condition
Rule 60    condition -> LPAREN condition RPAREN
Rule 61    comparison_op -> GT
Rule 62    comparison_op -> LT
Rule 63    comparison_op -> GE
Rule 64    comparison_op -> LE
Rule 65    comparison_op -> EQ
Rule 66    comparison_op -> NE
Rule 67    io_statement -> READ LPAREN IDF RPAREN
Rule 68    io_statement -> WRITE LPAREN write_list RPAREN
Rule 69    write_list -> write_list COMMA expression
Rule 70    write_list -> expression
Rule 71    write_list -> STRING
Rule 72    write_list -> write_list COMMA STRING
Rule 73    empty -> <empty>

Terminals, with rules where they appear

AND                  : 57
CHAR                 : 19 39
COLOM                : 51 51
COMMA                : 8 69 72
CONST                : 16
DECLARATION          : 1
DIVIDE               : 33 43
ELSE                 : 50
EQ                   : 65
EQUALS               : 12 16 28 29
FLOAT                : 18 38 48
FOR                  : 51
GE                   : 63
GT                   : 61
IDF                  : 10 11 12 16 28 29 35 36 45 46 52 54 67
IF                   : 49 50
INSTRUCTION          : 1
INTEGER              : 11 17 37 47 53 55
LBRACE               : 1 1 49 50 50 51
LBRACKET             : 11 29 36 46
LE                   : 64
LPAREN               : 34 44 49 50 51 60 67 68
LT                   : 62
MINUS                : 31 41
MULTIPLY             : 32 42
NE                   : 66
NOT                  : 59
OR                   : 58
PLUS                 : 30 40
RBRACE               : 1 1 49 50 50 51
RBRACKET             : 11 29 36 46
READ                 : 67
RPAREN               : 34 44 49 50 51 60 67 68
SEMICOL              : 7 16 23 24 27
STRING               : 71 72
TYPE_CHAR            : 15
TYPE_FLOAT           : 14
TYPE_INTEGER         : 13
WRITE                : 68
error                : 

Nonterminals, with rules where they appear

array_assignment     : 24
assignment           : 23 51
comparison_op        : 56
condition            : 49 50 57 57 58 58 59 60
const_declaration    : 6
const_value          : 12 16
declaration          : 2 3
declarations         : 1 2
empty                : 4 22
expression           : 28 29 29 56 56 69 70
expression2          : 30 30 31 31 32 32 33 33 34 36 40 40 41 41 42 42 43 43 44 46
for_condition        : 51
for_loop             : 26
for_pas              : 51
if_statement         : 25
instruction          : 20 21
instructions         : 1 20 49 50 50 51
io_statement         : 27
program              : 0
type                 : 7 16
type_declaration     : 5
var_item             : 8 9
var_list             : 7 8
write_list           : 68 69 72

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . DECLARATION LBRACE declarations RBRACE INSTRUCTION LBRACE instructions RBRACE

    DECLARATION     shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> DECLARATION . LBRACE declarations RBRACE INSTRUCTION LBRACE instructions RBRACE

    LBRACE          shift and go to state 3


state 3

    (1) program -> DECLARATION LBRACE . declarations RBRACE INSTRUCTION LBRACE instructions RBRACE
    (2) declarations -> . declarations declaration
    (3) declarations -> . declaration
    (4) declarations -> . empty
    (5) declaration -> . type_declaration
    (6) declaration -> . const_declaration
    (73) empty -> .
    (7) type_declaration -> . type var_list SEMICOL
    (16) const_declaration -> . CONST type IDF EQUALS const_value SEMICOL
    (13) type -> . TYPE_INTEGER
    (14) type -> . TYPE_FLOAT
    (15) type -> . TYPE_CHAR

  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for TYPE_INTEGER resolved as shift
  ! shift/reduce conflict for TYPE_FLOAT resolved as shift
  ! shift/reduce conflict for TYPE_CHAR resolved as shift
    RBRACE          reduce using rule 73 (empty -> .)
    CONST           shift and go to state 10
    TYPE_INTEGER    shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_CHAR       shift and go to state 13

  ! CONST           [ reduce using rule 73 (empty -> .) ]
  ! TYPE_INTEGER    [ reduce using rule 73 (empty -> .) ]
  ! TYPE_FLOAT      [ reduce using rule 73 (empty -> .) ]
  ! TYPE_CHAR       [ reduce using rule 73 (empty -> .) ]

    declarations                   shift and go to state 4
    declaration                    shift and go to state 5
    empty                          shift and go to state 6
    type_declaration               shift and go to state 7
    const_declaration              shift and go to state 8
    type                           shift and go to state 9

state 4

    (1) program -> DECLARATION LBRACE declarations . RBRACE INSTRUCTION LBRACE instructions RBRACE
    (2) declarations -> declarations . declaration
    (5) declaration -> . type_declaration
    (6) declaration -> . const_declaration
    (7) type_declaration -> . type var_list SEMICOL
    (16) const_declaration -> . CONST type IDF EQUALS const_value SEMICOL
    (13) type -> . TYPE_INTEGER
    (14) type -> . TYPE_FLOAT
    (15) type -> . TYPE_CHAR

    RBRACE          shift and go to state 14
    CONST           shift and go to state 10
    TYPE_INTEGER    shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_CHAR       shift and go to state 13

    declaration                    shift and go to state 15
    type_declaration               shift and go to state 7
    const_declaration              shift and go to state 8
    type                           shift and go to state 9

state 5

    (3) declarations -> declaration .

    RBRACE          reduce using rule 3 (declarations -> declaration .)
    CONST           reduce using rule 3 (declarations -> declaration .)
    TYPE_INTEGER    reduce using rule 3 (declarations -> declaration .)
    TYPE_FLOAT      reduce using rule 3 (declarations -> declaration .)
    TYPE_CHAR       reduce using rule 3 (declarations -> declaration .)


state 6

    (4) declarations -> empty .

    RBRACE          reduce using rule 4 (declarations -> empty .)
    CONST           reduce using rule 4 (declarations -> empty .)
    TYPE_INTEGER    reduce using rule 4 (declarations -> empty .)
    TYPE_FLOAT      reduce using rule 4 (declarations -> empty .)
    TYPE_CHAR       reduce using rule 4 (declarations -> empty .)


state 7

    (5) declaration -> type_declaration .

    RBRACE          reduce using rule 5 (declaration -> type_declaration .)
    CONST           reduce using rule 5 (declaration -> type_declaration .)
    TYPE_INTEGER    reduce using rule 5 (declaration -> type_declaration .)
    TYPE_FLOAT      reduce using rule 5 (declaration -> type_declaration .)
    TYPE_CHAR       reduce using rule 5 (declaration -> type_declaration .)


state 8

    (6) declaration -> const_declaration .

    RBRACE          reduce using rule 6 (declaration -> const_declaration .)
    CONST           reduce using rule 6 (declaration -> const_declaration .)
    TYPE_INTEGER    reduce using rule 6 (declaration -> const_declaration .)
    TYPE_FLOAT      reduce using rule 6 (declaration -> const_declaration .)
    TYPE_CHAR       reduce using rule 6 (declaration -> const_declaration .)


state 9

    (7) type_declaration -> type . var_list SEMICOL
    (8) var_list -> . var_list COMMA var_item
    (9) var_list -> . var_item
    (10) var_item -> . IDF
    (11) var_item -> . IDF LBRACKET INTEGER RBRACKET
    (12) var_item -> . IDF EQUALS const_value

    IDF             shift and go to state 18

    var_list                       shift and go to state 16
    var_item                       shift and go to state 17

state 10

    (16) const_declaration -> CONST . type IDF EQUALS const_value SEMICOL
    (13) type -> . TYPE_INTEGER
    (14) type -> . TYPE_FLOAT
    (15) type -> . TYPE_CHAR

    TYPE_INTEGER    shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_CHAR       shift and go to state 13

    type                           shift and go to state 19

state 11

    (13) type -> TYPE_INTEGER .

    IDF             reduce using rule 13 (type -> TYPE_INTEGER .)


state 12

    (14) type -> TYPE_FLOAT .

    IDF             reduce using rule 14 (type -> TYPE_FLOAT .)


state 13

    (15) type -> TYPE_CHAR .

    IDF             reduce using rule 15 (type -> TYPE_CHAR .)


state 14

    (1) program -> DECLARATION LBRACE declarations RBRACE . INSTRUCTION LBRACE instructions RBRACE

    INSTRUCTION     shift and go to state 20


state 15

    (2) declarations -> declarations declaration .

    RBRACE          reduce using rule 2 (declarations -> declarations declaration .)
    CONST           reduce using rule 2 (declarations -> declarations declaration .)
    TYPE_INTEGER    reduce using rule 2 (declarations -> declarations declaration .)
    TYPE_FLOAT      reduce using rule 2 (declarations -> declarations declaration .)
    TYPE_CHAR       reduce using rule 2 (declarations -> declarations declaration .)


state 16

    (7) type_declaration -> type var_list . SEMICOL
    (8) var_list -> var_list . COMMA var_item

    SEMICOL         shift and go to state 21
    COMMA           shift and go to state 22


state 17

    (9) var_list -> var_item .

    SEMICOL         reduce using rule 9 (var_list -> var_item .)
    COMMA           reduce using rule 9 (var_list -> var_item .)


state 18

    (10) var_item -> IDF .
    (11) var_item -> IDF . LBRACKET INTEGER RBRACKET
    (12) var_item -> IDF . EQUALS const_value

    SEMICOL         reduce using rule 10 (var_item -> IDF .)
    COMMA           reduce using rule 10 (var_item -> IDF .)
    LBRACKET        shift and go to state 23
    EQUALS          shift and go to state 24


state 19

    (16) const_declaration -> CONST type . IDF EQUALS const_value SEMICOL

    IDF             shift and go to state 25


state 20

    (1) program -> DECLARATION LBRACE declarations RBRACE INSTRUCTION . LBRACE instructions RBRACE

    LBRACE          shift and go to state 26


state 21

    (7) type_declaration -> type var_list SEMICOL .

    RBRACE          reduce using rule 7 (type_declaration -> type var_list SEMICOL .)
    CONST           reduce using rule 7 (type_declaration -> type var_list SEMICOL .)
    TYPE_INTEGER    reduce using rule 7 (type_declaration -> type var_list SEMICOL .)
    TYPE_FLOAT      reduce using rule 7 (type_declaration -> type var_list SEMICOL .)
    TYPE_CHAR       reduce using rule 7 (type_declaration -> type var_list SEMICOL .)


state 22

    (8) var_list -> var_list COMMA . var_item
    (10) var_item -> . IDF
    (11) var_item -> . IDF LBRACKET INTEGER RBRACKET
    (12) var_item -> . IDF EQUALS const_value

    IDF             shift and go to state 18

    var_item                       shift and go to state 27

state 23

    (11) var_item -> IDF LBRACKET . INTEGER RBRACKET

    INTEGER         shift and go to state 28


state 24

    (12) var_item -> IDF EQUALS . const_value
    (17) const_value -> . INTEGER
    (18) const_value -> . FLOAT
    (19) const_value -> . CHAR

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    CHAR            shift and go to state 32

    const_value                    shift and go to state 29

state 25

    (16) const_declaration -> CONST type IDF . EQUALS const_value SEMICOL

    EQUALS          shift and go to state 33


state 26

    (1) program -> DECLARATION LBRACE declarations RBRACE INSTRUCTION LBRACE . instructions RBRACE
    (20) instructions -> . instructions instruction
    (21) instructions -> . instruction
    (22) instructions -> . empty
    (23) instruction -> . assignment SEMICOL
    (24) instruction -> . array_assignment SEMICOL
    (25) instruction -> . if_statement
    (26) instruction -> . for_loop
    (27) instruction -> . io_statement SEMICOL
    (73) empty -> .
    (28) assignment -> . IDF EQUALS expression
    (29) array_assignment -> . IDF LBRACKET expression RBRACKET EQUALS expression
    (49) if_statement -> . IF LPAREN condition RPAREN LBRACE instructions RBRACE
    (50) if_statement -> . IF LPAREN condition RPAREN LBRACE instructions RBRACE ELSE LBRACE instructions RBRACE
    (51) for_loop -> . FOR LPAREN assignment COLOM for_pas COLOM for_condition RPAREN LBRACE instructions RBRACE
    (67) io_statement -> . READ LPAREN IDF RPAREN
    (68) io_statement -> . WRITE LPAREN write_list RPAREN

  ! shift/reduce conflict for IDF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
    RBRACE          reduce using rule 73 (empty -> .)
    IDF             shift and go to state 42
    IF              shift and go to state 43
    FOR             shift and go to state 44
    READ            shift and go to state 45
    WRITE           shift and go to state 46

  ! IDF             [ reduce using rule 73 (empty -> .) ]
  ! IF              [ reduce using rule 73 (empty -> .) ]
  ! FOR             [ reduce using rule 73 (empty -> .) ]
  ! READ            [ reduce using rule 73 (empty -> .) ]
  ! WRITE           [ reduce using rule 73 (empty -> .) ]

    instructions                   shift and go to state 34
    instruction                    shift and go to state 35
    empty                          shift and go to state 36
    assignment                     shift and go to state 37
    array_assignment               shift and go to state 38
    if_statement                   shift and go to state 39
    for_loop                       shift and go to state 40
    io_statement                   shift and go to state 41

state 27

    (8) var_list -> var_list COMMA var_item .

    SEMICOL         reduce using rule 8 (var_list -> var_list COMMA var_item .)
    COMMA           reduce using rule 8 (var_list -> var_list COMMA var_item .)


state 28

    (11) var_item -> IDF LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 47


state 29

    (12) var_item -> IDF EQUALS const_value .

    SEMICOL         reduce using rule 12 (var_item -> IDF EQUALS const_value .)
    COMMA           reduce using rule 12 (var_item -> IDF EQUALS const_value .)


state 30

    (17) const_value -> INTEGER .

    SEMICOL         reduce using rule 17 (const_value -> INTEGER .)
    COMMA           reduce using rule 17 (const_value -> INTEGER .)


state 31

    (18) const_value -> FLOAT .

    SEMICOL         reduce using rule 18 (const_value -> FLOAT .)
    COMMA           reduce using rule 18 (const_value -> FLOAT .)


state 32

    (19) const_value -> CHAR .

    SEMICOL         reduce using rule 19 (const_value -> CHAR .)
    COMMA           reduce using rule 19 (const_value -> CHAR .)


state 33

    (16) const_declaration -> CONST type IDF EQUALS . const_value SEMICOL
    (17) const_value -> . INTEGER
    (18) const_value -> . FLOAT
    (19) const_value -> . CHAR

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    CHAR            shift and go to state 32

    const_value                    shift and go to state 48

state 34

    (1) program -> DECLARATION LBRACE declarations RBRACE INSTRUCTION LBRACE instructions . RBRACE
    (20) instructions -> instructions . instruction
    (23) instruction -> . assignment SEMICOL
    (24) instruction -> . array_assignment SEMICOL
    (25) instruction -> . if_statement
    (26) instruction -> . for_loop
    (27) instruction -> . io_statement SEMICOL
    (28) assignment -> . IDF EQUALS expression
    (29) array_assignment -> . IDF LBRACKET expression RBRACKET EQUALS expression
    (49) if_statement -> . IF LPAREN condition RPAREN LBRACE instructions RBRACE
    (50) if_statement -> . IF LPAREN condition RPAREN LBRACE instructions RBRACE ELSE LBRACE instructions RBRACE
    (51) for_loop -> . FOR LPAREN assignment COLOM for_pas COLOM for_condition RPAREN LBRACE instructions RBRACE
    (67) io_statement -> . READ LPAREN IDF RPAREN
    (68) io_statement -> . WRITE LPAREN write_list RPAREN

    RBRACE          shift and go to state 49
    IDF             shift and go to state 42
    IF              shift and go to state 43
    FOR             shift and go to state 44
    READ            shift and go to state 45
    WRITE           shift and go to state 46

    instruction                    shift and go to state 50
    assignment                     shift and go to state 37
    array_assignment               shift and go to state 38
    if_statement                   shift and go to state 39
    for_loop                       shift and go to state 40
    io_statement                   shift and go to state 41

state 35

    (21) instructions -> instruction .

    RBRACE          reduce using rule 21 (instructions -> instruction .)
    IDF             reduce using rule 21 (instructions -> instruction .)
    IF              reduce using rule 21 (instructions -> instruction .)
    FOR             reduce using rule 21 (instructions -> instruction .)
    READ            reduce using rule 21 (instructions -> instruction .)
    WRITE           reduce using rule 21 (instructions -> instruction .)


state 36

    (22) instructions -> empty .

    RBRACE          reduce using rule 22 (instructions -> empty .)
    IDF             reduce using rule 22 (instructions -> empty .)
    IF              reduce using rule 22 (instructions -> empty .)
    FOR             reduce using rule 22 (instructions -> empty .)
    READ            reduce using rule 22 (instructions -> empty .)
    WRITE           reduce using rule 22 (instructions -> empty .)


state 37

    (23) instruction -> assignment . SEMICOL

    SEMICOL         shift and go to state 51


state 38

    (24) instruction -> array_assignment . SEMICOL

    SEMICOL         shift and go to state 52


state 39

    (25) instruction -> if_statement .

    RBRACE          reduce using rule 25 (instruction -> if_statement .)
    IDF             reduce using rule 25 (instruction -> if_statement .)
    IF              reduce using rule 25 (instruction -> if_statement .)
    FOR             reduce using rule 25 (instruction -> if_statement .)
    READ            reduce using rule 25 (instruction -> if_statement .)
    WRITE           reduce using rule 25 (instruction -> if_statement .)


state 40

    (26) instruction -> for_loop .

    RBRACE          reduce using rule 26 (instruction -> for_loop .)
    IDF             reduce using rule 26 (instruction -> for_loop .)
    IF              reduce using rule 26 (instruction -> for_loop .)
    FOR             reduce using rule 26 (instruction -> for_loop .)
    READ            reduce using rule 26 (instruction -> for_loop .)
    WRITE           reduce using rule 26 (instruction -> for_loop .)


state 41

    (27) instruction -> io_statement . SEMICOL

    SEMICOL         shift and go to state 53


state 42

    (28) assignment -> IDF . EQUALS expression
    (29) array_assignment -> IDF . LBRACKET expression RBRACKET EQUALS expression

    EQUALS          shift and go to state 54
    LBRACKET        shift and go to state 55


state 43

    (49) if_statement -> IF . LPAREN condition RPAREN LBRACE instructions RBRACE
    (50) if_statement -> IF . LPAREN condition RPAREN LBRACE instructions RBRACE ELSE LBRACE instructions RBRACE

    LPAREN          shift and go to state 56


state 44

    (51) for_loop -> FOR . LPAREN assignment COLOM for_pas COLOM for_condition RPAREN LBRACE instructions RBRACE

    LPAREN          shift and go to state 57


state 45

    (67) io_statement -> READ . LPAREN IDF RPAREN

    LPAREN          shift and go to state 58


state 46

    (68) io_statement -> WRITE . LPAREN write_list RPAREN

    LPAREN          shift and go to state 59


state 47

    (11) var_item -> IDF LBRACKET INTEGER RBRACKET .

    SEMICOL         reduce using rule 11 (var_item -> IDF LBRACKET INTEGER RBRACKET .)
    COMMA           reduce using rule 11 (var_item -> IDF LBRACKET INTEGER RBRACKET .)


state 48

    (16) const_declaration -> CONST type IDF EQUALS const_value . SEMICOL

    SEMICOL         shift and go to state 60


state 49

    (1) program -> DECLARATION LBRACE declarations RBRACE INSTRUCTION LBRACE instructions RBRACE .

    $end            reduce using rule 1 (program -> DECLARATION LBRACE declarations RBRACE INSTRUCTION LBRACE instructions RBRACE .)


state 50

    (20) instructions -> instructions instruction .

    RBRACE          reduce using rule 20 (instructions -> instructions instruction .)
    IDF             reduce using rule 20 (instructions -> instructions instruction .)
    IF              reduce using rule 20 (instructions -> instructions instruction .)
    FOR             reduce using rule 20 (instructions -> instructions instruction .)
    READ            reduce using rule 20 (instructions -> instructions instruction .)
    WRITE           reduce using rule 20 (instructions -> instructions instruction .)


state 51

    (23) instruction -> assignment SEMICOL .

    RBRACE          reduce using rule 23 (instruction -> assignment SEMICOL .)
    IDF             reduce using rule 23 (instruction -> assignment SEMICOL .)
    IF              reduce using rule 23 (instruction -> assignment SEMICOL .)
    FOR             reduce using rule 23 (instruction -> assignment SEMICOL .)
    READ            reduce using rule 23 (instruction -> assignment SEMICOL .)
    WRITE           reduce using rule 23 (instruction -> assignment SEMICOL .)


state 52

    (24) instruction -> array_assignment SEMICOL .

    RBRACE          reduce using rule 24 (instruction -> array_assignment SEMICOL .)
    IDF             reduce using rule 24 (instruction -> array_assignment SEMICOL .)
    IF              reduce using rule 24 (instruction -> array_assignment SEMICOL .)
    FOR             reduce using rule 24 (instruction -> array_assignment SEMICOL .)
    READ            reduce using rule 24 (instruction -> array_assignment SEMICOL .)
    WRITE           reduce using rule 24 (instruction -> array_assignment SEMICOL .)


state 53

    (27) instruction -> io_statement SEMICOL .

    RBRACE          reduce using rule 27 (instruction -> io_statement SEMICOL .)
    IDF             reduce using rule 27 (instruction -> io_statement SEMICOL .)
    IF              reduce using rule 27 (instruction -> io_statement SEMICOL .)
    FOR             reduce using rule 27 (instruction -> io_statement SEMICOL .)
    READ            reduce using rule 27 (instruction -> io_statement SEMICOL .)
    WRITE           reduce using rule 27 (instruction -> io_statement SEMICOL .)


state 54

    (28) assignment -> IDF EQUALS . expression
    (30) expression -> . expression2 PLUS expression2
    (31) expression -> . expression2 MINUS expression2
    (32) expression -> . expression2 MULTIPLY expression2
    (33) expression -> . expression2 DIVIDE expression2
    (34) expression -> . LPAREN expression2 RPAREN
    (35) expression -> . IDF
    (36) expression -> . IDF LBRACKET expression2 RBRACKET
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . CHAR
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    LPAREN          shift and go to state 64
    IDF             shift and go to state 61
    INTEGER         shift and go to state 65
    FLOAT           shift and go to state 66
    CHAR            shift and go to state 67

    expression                     shift and go to state 62
    expression2                    shift and go to state 63

state 55

    (29) array_assignment -> IDF LBRACKET . expression RBRACKET EQUALS expression
    (30) expression -> . expression2 PLUS expression2
    (31) expression -> . expression2 MINUS expression2
    (32) expression -> . expression2 MULTIPLY expression2
    (33) expression -> . expression2 DIVIDE expression2
    (34) expression -> . LPAREN expression2 RPAREN
    (35) expression -> . IDF
    (36) expression -> . IDF LBRACKET expression2 RBRACKET
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . CHAR
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    LPAREN          shift and go to state 64
    IDF             shift and go to state 61
    INTEGER         shift and go to state 65
    FLOAT           shift and go to state 66
    CHAR            shift and go to state 67

    expression                     shift and go to state 68
    expression2                    shift and go to state 63

state 56

    (49) if_statement -> IF LPAREN . condition RPAREN LBRACE instructions RBRACE
    (50) if_statement -> IF LPAREN . condition RPAREN LBRACE instructions RBRACE ELSE LBRACE instructions RBRACE
    (56) condition -> . expression comparison_op expression
    (57) condition -> . condition AND condition
    (58) condition -> . condition OR condition
    (59) condition -> . NOT condition
    (60) condition -> . LPAREN condition RPAREN
    (30) expression -> . expression2 PLUS expression2
    (31) expression -> . expression2 MINUS expression2
    (32) expression -> . expression2 MULTIPLY expression2
    (33) expression -> . expression2 DIVIDE expression2
    (34) expression -> . LPAREN expression2 RPAREN
    (35) expression -> . IDF
    (36) expression -> . IDF LBRACKET expression2 RBRACKET
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . CHAR
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    NOT             shift and go to state 72
    LPAREN          shift and go to state 69
    IDF             shift and go to state 61
    INTEGER         shift and go to state 65
    FLOAT           shift and go to state 66
    CHAR            shift and go to state 67

    condition                      shift and go to state 70
    expression                     shift and go to state 71
    expression2                    shift and go to state 63

state 57

    (51) for_loop -> FOR LPAREN . assignment COLOM for_pas COLOM for_condition RPAREN LBRACE instructions RBRACE
    (28) assignment -> . IDF EQUALS expression

    IDF             shift and go to state 74

    assignment                     shift and go to state 73

state 58

    (67) io_statement -> READ LPAREN . IDF RPAREN

    IDF             shift and go to state 75


state 59

    (68) io_statement -> WRITE LPAREN . write_list RPAREN
    (69) write_list -> . write_list COMMA expression
    (70) write_list -> . expression
    (71) write_list -> . STRING
    (72) write_list -> . write_list COMMA STRING
    (30) expression -> . expression2 PLUS expression2
    (31) expression -> . expression2 MINUS expression2
    (32) expression -> . expression2 MULTIPLY expression2
    (33) expression -> . expression2 DIVIDE expression2
    (34) expression -> . LPAREN expression2 RPAREN
    (35) expression -> . IDF
    (36) expression -> . IDF LBRACKET expression2 RBRACKET
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . CHAR
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    STRING          shift and go to state 78
    LPAREN          shift and go to state 64
    IDF             shift and go to state 61
    INTEGER         shift and go to state 65
    FLOAT           shift and go to state 66
    CHAR            shift and go to state 67

    write_list                     shift and go to state 76
    expression                     shift and go to state 77
    expression2                    shift and go to state 63

state 60

    (16) const_declaration -> CONST type IDF EQUALS const_value SEMICOL .

    RBRACE          reduce using rule 16 (const_declaration -> CONST type IDF EQUALS const_value SEMICOL .)
    CONST           reduce using rule 16 (const_declaration -> CONST type IDF EQUALS const_value SEMICOL .)
    TYPE_INTEGER    reduce using rule 16 (const_declaration -> CONST type IDF EQUALS const_value SEMICOL .)
    TYPE_FLOAT      reduce using rule 16 (const_declaration -> CONST type IDF EQUALS const_value SEMICOL .)
    TYPE_CHAR       reduce using rule 16 (const_declaration -> CONST type IDF EQUALS const_value SEMICOL .)


state 61

    (35) expression -> IDF .
    (36) expression -> IDF . LBRACKET expression2 RBRACKET
    (45) expression2 -> IDF .
    (46) expression2 -> IDF . LBRACKET expression2 RBRACKET

    SEMICOL         reduce using rule 35 (expression -> IDF .)
    COLOM           reduce using rule 35 (expression -> IDF .)
    RBRACKET        reduce using rule 35 (expression -> IDF .)
    GT              reduce using rule 35 (expression -> IDF .)
    LT              reduce using rule 35 (expression -> IDF .)
    GE              reduce using rule 35 (expression -> IDF .)
    LE              reduce using rule 35 (expression -> IDF .)
    EQ              reduce using rule 35 (expression -> IDF .)
    NE              reduce using rule 35 (expression -> IDF .)
    RPAREN          reduce using rule 35 (expression -> IDF .)
    COMMA           reduce using rule 35 (expression -> IDF .)
    AND             reduce using rule 35 (expression -> IDF .)
    OR              reduce using rule 35 (expression -> IDF .)
    LBRACKET        shift and go to state 79
    PLUS            reduce using rule 45 (expression2 -> IDF .)
    MINUS           reduce using rule 45 (expression2 -> IDF .)
    MULTIPLY        reduce using rule 45 (expression2 -> IDF .)
    DIVIDE          reduce using rule 45 (expression2 -> IDF .)


state 62

    (28) assignment -> IDF EQUALS expression .

    SEMICOL         reduce using rule 28 (assignment -> IDF EQUALS expression .)
    COLOM           reduce using rule 28 (assignment -> IDF EQUALS expression .)


state 63

    (30) expression -> expression2 . PLUS expression2
    (31) expression -> expression2 . MINUS expression2
    (32) expression -> expression2 . MULTIPLY expression2
    (33) expression -> expression2 . DIVIDE expression2
    (40) expression2 -> expression2 . PLUS expression2
    (41) expression2 -> expression2 . MINUS expression2
    (42) expression2 -> expression2 . MULTIPLY expression2
    (43) expression2 -> expression2 . DIVIDE expression2

    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    MULTIPLY        shift and go to state 82
    DIVIDE          shift and go to state 83


state 64

    (34) expression -> LPAREN . expression2 RPAREN
    (44) expression2 -> LPAREN . expression2 RPAREN
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    LPAREN          shift and go to state 84
    IDF             shift and go to state 86
    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88

    expression2                    shift and go to state 85

state 65

    (37) expression -> INTEGER .
    (47) expression2 -> INTEGER .

    SEMICOL         reduce using rule 37 (expression -> INTEGER .)
    COLOM           reduce using rule 37 (expression -> INTEGER .)
    RBRACKET        reduce using rule 37 (expression -> INTEGER .)
    GT              reduce using rule 37 (expression -> INTEGER .)
    LT              reduce using rule 37 (expression -> INTEGER .)
    GE              reduce using rule 37 (expression -> INTEGER .)
    LE              reduce using rule 37 (expression -> INTEGER .)
    EQ              reduce using rule 37 (expression -> INTEGER .)
    NE              reduce using rule 37 (expression -> INTEGER .)
    RPAREN          reduce using rule 37 (expression -> INTEGER .)
    COMMA           reduce using rule 37 (expression -> INTEGER .)
    AND             reduce using rule 37 (expression -> INTEGER .)
    OR              reduce using rule 37 (expression -> INTEGER .)
    PLUS            reduce using rule 47 (expression2 -> INTEGER .)
    MINUS           reduce using rule 47 (expression2 -> INTEGER .)
    MULTIPLY        reduce using rule 47 (expression2 -> INTEGER .)
    DIVIDE          reduce using rule 47 (expression2 -> INTEGER .)


state 66

    (38) expression -> FLOAT .
    (48) expression2 -> FLOAT .

    SEMICOL         reduce using rule 38 (expression -> FLOAT .)
    COLOM           reduce using rule 38 (expression -> FLOAT .)
    RBRACKET        reduce using rule 38 (expression -> FLOAT .)
    GT              reduce using rule 38 (expression -> FLOAT .)
    LT              reduce using rule 38 (expression -> FLOAT .)
    GE              reduce using rule 38 (expression -> FLOAT .)
    LE              reduce using rule 38 (expression -> FLOAT .)
    EQ              reduce using rule 38 (expression -> FLOAT .)
    NE              reduce using rule 38 (expression -> FLOAT .)
    RPAREN          reduce using rule 38 (expression -> FLOAT .)
    COMMA           reduce using rule 38 (expression -> FLOAT .)
    AND             reduce using rule 38 (expression -> FLOAT .)
    OR              reduce using rule 38 (expression -> FLOAT .)
    PLUS            reduce using rule 48 (expression2 -> FLOAT .)
    MINUS           reduce using rule 48 (expression2 -> FLOAT .)
    MULTIPLY        reduce using rule 48 (expression2 -> FLOAT .)
    DIVIDE          reduce using rule 48 (expression2 -> FLOAT .)


state 67

    (39) expression -> CHAR .

    SEMICOL         reduce using rule 39 (expression -> CHAR .)
    COLOM           reduce using rule 39 (expression -> CHAR .)
    RBRACKET        reduce using rule 39 (expression -> CHAR .)
    GT              reduce using rule 39 (expression -> CHAR .)
    LT              reduce using rule 39 (expression -> CHAR .)
    GE              reduce using rule 39 (expression -> CHAR .)
    LE              reduce using rule 39 (expression -> CHAR .)
    EQ              reduce using rule 39 (expression -> CHAR .)
    NE              reduce using rule 39 (expression -> CHAR .)
    RPAREN          reduce using rule 39 (expression -> CHAR .)
    COMMA           reduce using rule 39 (expression -> CHAR .)
    AND             reduce using rule 39 (expression -> CHAR .)
    OR              reduce using rule 39 (expression -> CHAR .)


state 68

    (29) array_assignment -> IDF LBRACKET expression . RBRACKET EQUALS expression

    RBRACKET        shift and go to state 89


state 69

    (60) condition -> LPAREN . condition RPAREN
    (34) expression -> LPAREN . expression2 RPAREN
    (44) expression2 -> LPAREN . expression2 RPAREN
    (56) condition -> . expression comparison_op expression
    (57) condition -> . condition AND condition
    (58) condition -> . condition OR condition
    (59) condition -> . NOT condition
    (60) condition -> . LPAREN condition RPAREN
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT
    (30) expression -> . expression2 PLUS expression2
    (31) expression -> . expression2 MINUS expression2
    (32) expression -> . expression2 MULTIPLY expression2
    (33) expression -> . expression2 DIVIDE expression2
    (34) expression -> . LPAREN expression2 RPAREN
    (35) expression -> . IDF
    (36) expression -> . IDF LBRACKET expression2 RBRACKET
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . CHAR

    NOT             shift and go to state 72
    LPAREN          shift and go to state 90
    IDF             shift and go to state 93
    INTEGER         shift and go to state 94
    FLOAT           shift and go to state 95
    CHAR            shift and go to state 67

    condition                      shift and go to state 91
    expression2                    shift and go to state 92
    expression                     shift and go to state 71

state 70

    (49) if_statement -> IF LPAREN condition . RPAREN LBRACE instructions RBRACE
    (50) if_statement -> IF LPAREN condition . RPAREN LBRACE instructions RBRACE ELSE LBRACE instructions RBRACE
    (57) condition -> condition . AND condition
    (58) condition -> condition . OR condition

    RPAREN          shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98


state 71

    (56) condition -> expression . comparison_op expression
    (61) comparison_op -> . GT
    (62) comparison_op -> . LT
    (63) comparison_op -> . GE
    (64) comparison_op -> . LE
    (65) comparison_op -> . EQ
    (66) comparison_op -> . NE

    GT              shift and go to state 100
    LT              shift and go to state 101
    GE              shift and go to state 102
    LE              shift and go to state 103
    EQ              shift and go to state 104
    NE              shift and go to state 105

    comparison_op                  shift and go to state 99

state 72

    (59) condition -> NOT . condition
    (56) condition -> . expression comparison_op expression
    (57) condition -> . condition AND condition
    (58) condition -> . condition OR condition
    (59) condition -> . NOT condition
    (60) condition -> . LPAREN condition RPAREN
    (30) expression -> . expression2 PLUS expression2
    (31) expression -> . expression2 MINUS expression2
    (32) expression -> . expression2 MULTIPLY expression2
    (33) expression -> . expression2 DIVIDE expression2
    (34) expression -> . LPAREN expression2 RPAREN
    (35) expression -> . IDF
    (36) expression -> . IDF LBRACKET expression2 RBRACKET
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . CHAR
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    NOT             shift and go to state 72
    LPAREN          shift and go to state 69
    IDF             shift and go to state 61
    INTEGER         shift and go to state 65
    FLOAT           shift and go to state 66
    CHAR            shift and go to state 67

    condition                      shift and go to state 106
    expression                     shift and go to state 71
    expression2                    shift and go to state 63

state 73

    (51) for_loop -> FOR LPAREN assignment . COLOM for_pas COLOM for_condition RPAREN LBRACE instructions RBRACE

    COLOM           shift and go to state 107


state 74

    (28) assignment -> IDF . EQUALS expression

    EQUALS          shift and go to state 54


state 75

    (67) io_statement -> READ LPAREN IDF . RPAREN

    RPAREN          shift and go to state 108


state 76

    (68) io_statement -> WRITE LPAREN write_list . RPAREN
    (69) write_list -> write_list . COMMA expression
    (72) write_list -> write_list . COMMA STRING

    RPAREN          shift and go to state 109
    COMMA           shift and go to state 110


state 77

    (70) write_list -> expression .

    RPAREN          reduce using rule 70 (write_list -> expression .)
    COMMA           reduce using rule 70 (write_list -> expression .)


state 78

    (71) write_list -> STRING .

    RPAREN          reduce using rule 71 (write_list -> STRING .)
    COMMA           reduce using rule 71 (write_list -> STRING .)


state 79

    (36) expression -> IDF LBRACKET . expression2 RBRACKET
    (46) expression2 -> IDF LBRACKET . expression2 RBRACKET
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    LPAREN          shift and go to state 84
    IDF             shift and go to state 86
    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88

    expression2                    shift and go to state 111

state 80

    (30) expression -> expression2 PLUS . expression2
    (40) expression2 -> expression2 PLUS . expression2
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    LPAREN          shift and go to state 84
    IDF             shift and go to state 86
    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88

    expression2                    shift and go to state 112

state 81

    (31) expression -> expression2 MINUS . expression2
    (41) expression2 -> expression2 MINUS . expression2
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    LPAREN          shift and go to state 84
    IDF             shift and go to state 86
    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88

    expression2                    shift and go to state 113

state 82

    (32) expression -> expression2 MULTIPLY . expression2
    (42) expression2 -> expression2 MULTIPLY . expression2
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    LPAREN          shift and go to state 84
    IDF             shift and go to state 86
    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88

    expression2                    shift and go to state 114

state 83

    (33) expression -> expression2 DIVIDE . expression2
    (43) expression2 -> expression2 DIVIDE . expression2
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    LPAREN          shift and go to state 84
    IDF             shift and go to state 86
    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88

    expression2                    shift and go to state 115

state 84

    (44) expression2 -> LPAREN . expression2 RPAREN
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    LPAREN          shift and go to state 84
    IDF             shift and go to state 86
    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88

    expression2                    shift and go to state 116

state 85

    (34) expression -> LPAREN expression2 . RPAREN
    (44) expression2 -> LPAREN expression2 . RPAREN
    (40) expression2 -> expression2 . PLUS expression2
    (41) expression2 -> expression2 . MINUS expression2
    (42) expression2 -> expression2 . MULTIPLY expression2
    (43) expression2 -> expression2 . DIVIDE expression2

    RPAREN          shift and go to state 117
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121


state 86

    (45) expression2 -> IDF .
    (46) expression2 -> IDF . LBRACKET expression2 RBRACKET

    RPAREN          reduce using rule 45 (expression2 -> IDF .)
    PLUS            reduce using rule 45 (expression2 -> IDF .)
    MINUS           reduce using rule 45 (expression2 -> IDF .)
    MULTIPLY        reduce using rule 45 (expression2 -> IDF .)
    DIVIDE          reduce using rule 45 (expression2 -> IDF .)
    RBRACKET        reduce using rule 45 (expression2 -> IDF .)
    SEMICOL         reduce using rule 45 (expression2 -> IDF .)
    COLOM           reduce using rule 45 (expression2 -> IDF .)
    GT              reduce using rule 45 (expression2 -> IDF .)
    LT              reduce using rule 45 (expression2 -> IDF .)
    GE              reduce using rule 45 (expression2 -> IDF .)
    LE              reduce using rule 45 (expression2 -> IDF .)
    EQ              reduce using rule 45 (expression2 -> IDF .)
    NE              reduce using rule 45 (expression2 -> IDF .)
    COMMA           reduce using rule 45 (expression2 -> IDF .)
    AND             reduce using rule 45 (expression2 -> IDF .)
    OR              reduce using rule 45 (expression2 -> IDF .)
    LBRACKET        shift and go to state 122


state 87

    (47) expression2 -> INTEGER .

    RPAREN          reduce using rule 47 (expression2 -> INTEGER .)
    PLUS            reduce using rule 47 (expression2 -> INTEGER .)
    MINUS           reduce using rule 47 (expression2 -> INTEGER .)
    MULTIPLY        reduce using rule 47 (expression2 -> INTEGER .)
    DIVIDE          reduce using rule 47 (expression2 -> INTEGER .)
    RBRACKET        reduce using rule 47 (expression2 -> INTEGER .)
    SEMICOL         reduce using rule 47 (expression2 -> INTEGER .)
    COLOM           reduce using rule 47 (expression2 -> INTEGER .)
    GT              reduce using rule 47 (expression2 -> INTEGER .)
    LT              reduce using rule 47 (expression2 -> INTEGER .)
    GE              reduce using rule 47 (expression2 -> INTEGER .)
    LE              reduce using rule 47 (expression2 -> INTEGER .)
    EQ              reduce using rule 47 (expression2 -> INTEGER .)
    NE              reduce using rule 47 (expression2 -> INTEGER .)
    COMMA           reduce using rule 47 (expression2 -> INTEGER .)
    AND             reduce using rule 47 (expression2 -> INTEGER .)
    OR              reduce using rule 47 (expression2 -> INTEGER .)


state 88

    (48) expression2 -> FLOAT .

    RPAREN          reduce using rule 48 (expression2 -> FLOAT .)
    PLUS            reduce using rule 48 (expression2 -> FLOAT .)
    MINUS           reduce using rule 48 (expression2 -> FLOAT .)
    MULTIPLY        reduce using rule 48 (expression2 -> FLOAT .)
    DIVIDE          reduce using rule 48 (expression2 -> FLOAT .)
    RBRACKET        reduce using rule 48 (expression2 -> FLOAT .)
    SEMICOL         reduce using rule 48 (expression2 -> FLOAT .)
    COLOM           reduce using rule 48 (expression2 -> FLOAT .)
    GT              reduce using rule 48 (expression2 -> FLOAT .)
    LT              reduce using rule 48 (expression2 -> FLOAT .)
    GE              reduce using rule 48 (expression2 -> FLOAT .)
    LE              reduce using rule 48 (expression2 -> FLOAT .)
    EQ              reduce using rule 48 (expression2 -> FLOAT .)
    NE              reduce using rule 48 (expression2 -> FLOAT .)
    COMMA           reduce using rule 48 (expression2 -> FLOAT .)
    AND             reduce using rule 48 (expression2 -> FLOAT .)
    OR              reduce using rule 48 (expression2 -> FLOAT .)


state 89

    (29) array_assignment -> IDF LBRACKET expression RBRACKET . EQUALS expression

    EQUALS          shift and go to state 123


state 90

    (60) condition -> LPAREN . condition RPAREN
    (44) expression2 -> LPAREN . expression2 RPAREN
    (34) expression -> LPAREN . expression2 RPAREN
    (56) condition -> . expression comparison_op expression
    (57) condition -> . condition AND condition
    (58) condition -> . condition OR condition
    (59) condition -> . NOT condition
    (60) condition -> . LPAREN condition RPAREN
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT
    (30) expression -> . expression2 PLUS expression2
    (31) expression -> . expression2 MINUS expression2
    (32) expression -> . expression2 MULTIPLY expression2
    (33) expression -> . expression2 DIVIDE expression2
    (34) expression -> . LPAREN expression2 RPAREN
    (35) expression -> . IDF
    (36) expression -> . IDF LBRACKET expression2 RBRACKET
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . CHAR

    NOT             shift and go to state 72
    LPAREN          shift and go to state 90
    IDF             shift and go to state 93
    INTEGER         shift and go to state 94
    FLOAT           shift and go to state 95
    CHAR            shift and go to state 67

    condition                      shift and go to state 91
    expression2                    shift and go to state 124
    expression                     shift and go to state 71

state 91

    (60) condition -> LPAREN condition . RPAREN
    (57) condition -> condition . AND condition
    (58) condition -> condition . OR condition

    RPAREN          shift and go to state 125
    AND             shift and go to state 97
    OR              shift and go to state 98


state 92

    (34) expression -> LPAREN expression2 . RPAREN
    (44) expression2 -> LPAREN expression2 . RPAREN
    (40) expression2 -> expression2 . PLUS expression2
    (41) expression2 -> expression2 . MINUS expression2
    (42) expression2 -> expression2 . MULTIPLY expression2
    (43) expression2 -> expression2 . DIVIDE expression2
    (30) expression -> expression2 . PLUS expression2
    (31) expression -> expression2 . MINUS expression2
    (32) expression -> expression2 . MULTIPLY expression2
    (33) expression -> expression2 . DIVIDE expression2

    RPAREN          shift and go to state 117
    PLUS            shift and go to state 126
    MINUS           shift and go to state 127
    MULTIPLY        shift and go to state 128
    DIVIDE          shift and go to state 129


state 93

    (45) expression2 -> IDF .
    (46) expression2 -> IDF . LBRACKET expression2 RBRACKET
    (35) expression -> IDF .
    (36) expression -> IDF . LBRACKET expression2 RBRACKET

    RPAREN          reduce using rule 45 (expression2 -> IDF .)
    PLUS            reduce using rule 45 (expression2 -> IDF .)
    MINUS           reduce using rule 45 (expression2 -> IDF .)
    MULTIPLY        reduce using rule 45 (expression2 -> IDF .)
    DIVIDE          reduce using rule 45 (expression2 -> IDF .)
    LBRACKET        shift and go to state 130
    GT              reduce using rule 35 (expression -> IDF .)
    LT              reduce using rule 35 (expression -> IDF .)
    GE              reduce using rule 35 (expression -> IDF .)
    LE              reduce using rule 35 (expression -> IDF .)
    EQ              reduce using rule 35 (expression -> IDF .)
    NE              reduce using rule 35 (expression -> IDF .)


state 94

    (47) expression2 -> INTEGER .
    (37) expression -> INTEGER .

    RPAREN          reduce using rule 47 (expression2 -> INTEGER .)
    PLUS            reduce using rule 47 (expression2 -> INTEGER .)
    MINUS           reduce using rule 47 (expression2 -> INTEGER .)
    MULTIPLY        reduce using rule 47 (expression2 -> INTEGER .)
    DIVIDE          reduce using rule 47 (expression2 -> INTEGER .)
    GT              reduce using rule 37 (expression -> INTEGER .)
    LT              reduce using rule 37 (expression -> INTEGER .)
    GE              reduce using rule 37 (expression -> INTEGER .)
    LE              reduce using rule 37 (expression -> INTEGER .)
    EQ              reduce using rule 37 (expression -> INTEGER .)
    NE              reduce using rule 37 (expression -> INTEGER .)


state 95

    (48) expression2 -> FLOAT .
    (38) expression -> FLOAT .

    RPAREN          reduce using rule 48 (expression2 -> FLOAT .)
    PLUS            reduce using rule 48 (expression2 -> FLOAT .)
    MINUS           reduce using rule 48 (expression2 -> FLOAT .)
    MULTIPLY        reduce using rule 48 (expression2 -> FLOAT .)
    DIVIDE          reduce using rule 48 (expression2 -> FLOAT .)
    GT              reduce using rule 38 (expression -> FLOAT .)
    LT              reduce using rule 38 (expression -> FLOAT .)
    GE              reduce using rule 38 (expression -> FLOAT .)
    LE              reduce using rule 38 (expression -> FLOAT .)
    EQ              reduce using rule 38 (expression -> FLOAT .)
    NE              reduce using rule 38 (expression -> FLOAT .)


state 96

    (49) if_statement -> IF LPAREN condition RPAREN . LBRACE instructions RBRACE
    (50) if_statement -> IF LPAREN condition RPAREN . LBRACE instructions RBRACE ELSE LBRACE instructions RBRACE

    LBRACE          shift and go to state 131


state 97

    (57) condition -> condition AND . condition
    (56) condition -> . expression comparison_op expression
    (57) condition -> . condition AND condition
    (58) condition -> . condition OR condition
    (59) condition -> . NOT condition
    (60) condition -> . LPAREN condition RPAREN
    (30) expression -> . expression2 PLUS expression2
    (31) expression -> . expression2 MINUS expression2
    (32) expression -> . expression2 MULTIPLY expression2
    (33) expression -> . expression2 DIVIDE expression2
    (34) expression -> . LPAREN expression2 RPAREN
    (35) expression -> . IDF
    (36) expression -> . IDF LBRACKET expression2 RBRACKET
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . CHAR
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    NOT             shift and go to state 72
    LPAREN          shift and go to state 69
    IDF             shift and go to state 61
    INTEGER         shift and go to state 65
    FLOAT           shift and go to state 66
    CHAR            shift and go to state 67

    condition                      shift and go to state 132
    expression                     shift and go to state 71
    expression2                    shift and go to state 63

state 98

    (58) condition -> condition OR . condition
    (56) condition -> . expression comparison_op expression
    (57) condition -> . condition AND condition
    (58) condition -> . condition OR condition
    (59) condition -> . NOT condition
    (60) condition -> . LPAREN condition RPAREN
    (30) expression -> . expression2 PLUS expression2
    (31) expression -> . expression2 MINUS expression2
    (32) expression -> . expression2 MULTIPLY expression2
    (33) expression -> . expression2 DIVIDE expression2
    (34) expression -> . LPAREN expression2 RPAREN
    (35) expression -> . IDF
    (36) expression -> . IDF LBRACKET expression2 RBRACKET
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . CHAR
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    NOT             shift and go to state 72
    LPAREN          shift and go to state 69
    IDF             shift and go to state 61
    INTEGER         shift and go to state 65
    FLOAT           shift and go to state 66
    CHAR            shift and go to state 67

    condition                      shift and go to state 133
    expression                     shift and go to state 71
    expression2                    shift and go to state 63

state 99

    (56) condition -> expression comparison_op . expression
    (30) expression -> . expression2 PLUS expression2
    (31) expression -> . expression2 MINUS expression2
    (32) expression -> . expression2 MULTIPLY expression2
    (33) expression -> . expression2 DIVIDE expression2
    (34) expression -> . LPAREN expression2 RPAREN
    (35) expression -> . IDF
    (36) expression -> . IDF LBRACKET expression2 RBRACKET
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . CHAR
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    LPAREN          shift and go to state 64
    IDF             shift and go to state 61
    INTEGER         shift and go to state 65
    FLOAT           shift and go to state 66
    CHAR            shift and go to state 67

    expression                     shift and go to state 134
    expression2                    shift and go to state 63

state 100

    (61) comparison_op -> GT .

    LPAREN          reduce using rule 61 (comparison_op -> GT .)
    IDF             reduce using rule 61 (comparison_op -> GT .)
    INTEGER         reduce using rule 61 (comparison_op -> GT .)
    FLOAT           reduce using rule 61 (comparison_op -> GT .)
    CHAR            reduce using rule 61 (comparison_op -> GT .)


state 101

    (62) comparison_op -> LT .

    LPAREN          reduce using rule 62 (comparison_op -> LT .)
    IDF             reduce using rule 62 (comparison_op -> LT .)
    INTEGER         reduce using rule 62 (comparison_op -> LT .)
    FLOAT           reduce using rule 62 (comparison_op -> LT .)
    CHAR            reduce using rule 62 (comparison_op -> LT .)


state 102

    (63) comparison_op -> GE .

    LPAREN          reduce using rule 63 (comparison_op -> GE .)
    IDF             reduce using rule 63 (comparison_op -> GE .)
    INTEGER         reduce using rule 63 (comparison_op -> GE .)
    FLOAT           reduce using rule 63 (comparison_op -> GE .)
    CHAR            reduce using rule 63 (comparison_op -> GE .)


state 103

    (64) comparison_op -> LE .

    LPAREN          reduce using rule 64 (comparison_op -> LE .)
    IDF             reduce using rule 64 (comparison_op -> LE .)
    INTEGER         reduce using rule 64 (comparison_op -> LE .)
    FLOAT           reduce using rule 64 (comparison_op -> LE .)
    CHAR            reduce using rule 64 (comparison_op -> LE .)


state 104

    (65) comparison_op -> EQ .

    LPAREN          reduce using rule 65 (comparison_op -> EQ .)
    IDF             reduce using rule 65 (comparison_op -> EQ .)
    INTEGER         reduce using rule 65 (comparison_op -> EQ .)
    FLOAT           reduce using rule 65 (comparison_op -> EQ .)
    CHAR            reduce using rule 65 (comparison_op -> EQ .)


state 105

    (66) comparison_op -> NE .

    LPAREN          reduce using rule 66 (comparison_op -> NE .)
    IDF             reduce using rule 66 (comparison_op -> NE .)
    INTEGER         reduce using rule 66 (comparison_op -> NE .)
    FLOAT           reduce using rule 66 (comparison_op -> NE .)
    CHAR            reduce using rule 66 (comparison_op -> NE .)


state 106

    (59) condition -> NOT condition .
    (57) condition -> condition . AND condition
    (58) condition -> condition . OR condition

    RPAREN          reduce using rule 59 (condition -> NOT condition .)
    AND             reduce using rule 59 (condition -> NOT condition .)
    OR              reduce using rule 59 (condition -> NOT condition .)

  ! AND             [ shift and go to state 97 ]
  ! OR              [ shift and go to state 98 ]


state 107

    (51) for_loop -> FOR LPAREN assignment COLOM . for_pas COLOM for_condition RPAREN LBRACE instructions RBRACE
    (52) for_pas -> . IDF
    (53) for_pas -> . INTEGER

    IDF             shift and go to state 136
    INTEGER         shift and go to state 137

    for_pas                        shift and go to state 135

state 108

    (67) io_statement -> READ LPAREN IDF RPAREN .

    SEMICOL         reduce using rule 67 (io_statement -> READ LPAREN IDF RPAREN .)


state 109

    (68) io_statement -> WRITE LPAREN write_list RPAREN .

    SEMICOL         reduce using rule 68 (io_statement -> WRITE LPAREN write_list RPAREN .)


state 110

    (69) write_list -> write_list COMMA . expression
    (72) write_list -> write_list COMMA . STRING
    (30) expression -> . expression2 PLUS expression2
    (31) expression -> . expression2 MINUS expression2
    (32) expression -> . expression2 MULTIPLY expression2
    (33) expression -> . expression2 DIVIDE expression2
    (34) expression -> . LPAREN expression2 RPAREN
    (35) expression -> . IDF
    (36) expression -> . IDF LBRACKET expression2 RBRACKET
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . CHAR
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    STRING          shift and go to state 139
    LPAREN          shift and go to state 64
    IDF             shift and go to state 61
    INTEGER         shift and go to state 65
    FLOAT           shift and go to state 66
    CHAR            shift and go to state 67

    expression                     shift and go to state 138
    expression2                    shift and go to state 63

state 111

    (36) expression -> IDF LBRACKET expression2 . RBRACKET
    (46) expression2 -> IDF LBRACKET expression2 . RBRACKET
    (40) expression2 -> expression2 . PLUS expression2
    (41) expression2 -> expression2 . MINUS expression2
    (42) expression2 -> expression2 . MULTIPLY expression2
    (43) expression2 -> expression2 . DIVIDE expression2

    RBRACKET        shift and go to state 140
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121


state 112

    (30) expression -> expression2 PLUS expression2 .
    (40) expression2 -> expression2 PLUS expression2 .
    (40) expression2 -> expression2 . PLUS expression2
    (41) expression2 -> expression2 . MINUS expression2
    (42) expression2 -> expression2 . MULTIPLY expression2
    (43) expression2 -> expression2 . DIVIDE expression2

    SEMICOL         reduce using rule 30 (expression -> expression2 PLUS expression2 .)
    COLOM           reduce using rule 30 (expression -> expression2 PLUS expression2 .)
    RBRACKET        reduce using rule 30 (expression -> expression2 PLUS expression2 .)
    GT              reduce using rule 30 (expression -> expression2 PLUS expression2 .)
    LT              reduce using rule 30 (expression -> expression2 PLUS expression2 .)
    GE              reduce using rule 30 (expression -> expression2 PLUS expression2 .)
    LE              reduce using rule 30 (expression -> expression2 PLUS expression2 .)
    EQ              reduce using rule 30 (expression -> expression2 PLUS expression2 .)
    NE              reduce using rule 30 (expression -> expression2 PLUS expression2 .)
    RPAREN          reduce using rule 30 (expression -> expression2 PLUS expression2 .)
    COMMA           reduce using rule 30 (expression -> expression2 PLUS expression2 .)
    AND             reduce using rule 30 (expression -> expression2 PLUS expression2 .)
    OR              reduce using rule 30 (expression -> expression2 PLUS expression2 .)
    PLUS            reduce using rule 40 (expression2 -> expression2 PLUS expression2 .)
    MINUS           reduce using rule 40 (expression2 -> expression2 PLUS expression2 .)
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121

  ! MULTIPLY        [ reduce using rule 40 (expression2 -> expression2 PLUS expression2 .) ]
  ! DIVIDE          [ reduce using rule 40 (expression2 -> expression2 PLUS expression2 .) ]
  ! PLUS            [ shift and go to state 118 ]
  ! MINUS           [ shift and go to state 119 ]


state 113

    (31) expression -> expression2 MINUS expression2 .
    (41) expression2 -> expression2 MINUS expression2 .
    (40) expression2 -> expression2 . PLUS expression2
    (41) expression2 -> expression2 . MINUS expression2
    (42) expression2 -> expression2 . MULTIPLY expression2
    (43) expression2 -> expression2 . DIVIDE expression2

    SEMICOL         reduce using rule 31 (expression -> expression2 MINUS expression2 .)
    COLOM           reduce using rule 31 (expression -> expression2 MINUS expression2 .)
    RBRACKET        reduce using rule 31 (expression -> expression2 MINUS expression2 .)
    GT              reduce using rule 31 (expression -> expression2 MINUS expression2 .)
    LT              reduce using rule 31 (expression -> expression2 MINUS expression2 .)
    GE              reduce using rule 31 (expression -> expression2 MINUS expression2 .)
    LE              reduce using rule 31 (expression -> expression2 MINUS expression2 .)
    EQ              reduce using rule 31 (expression -> expression2 MINUS expression2 .)
    NE              reduce using rule 31 (expression -> expression2 MINUS expression2 .)
    RPAREN          reduce using rule 31 (expression -> expression2 MINUS expression2 .)
    COMMA           reduce using rule 31 (expression -> expression2 MINUS expression2 .)
    AND             reduce using rule 31 (expression -> expression2 MINUS expression2 .)
    OR              reduce using rule 31 (expression -> expression2 MINUS expression2 .)
    PLUS            reduce using rule 41 (expression2 -> expression2 MINUS expression2 .)
    MINUS           reduce using rule 41 (expression2 -> expression2 MINUS expression2 .)
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121

  ! MULTIPLY        [ reduce using rule 41 (expression2 -> expression2 MINUS expression2 .) ]
  ! DIVIDE          [ reduce using rule 41 (expression2 -> expression2 MINUS expression2 .) ]
  ! PLUS            [ shift and go to state 118 ]
  ! MINUS           [ shift and go to state 119 ]


state 114

    (32) expression -> expression2 MULTIPLY expression2 .
    (42) expression2 -> expression2 MULTIPLY expression2 .
    (40) expression2 -> expression2 . PLUS expression2
    (41) expression2 -> expression2 . MINUS expression2
    (42) expression2 -> expression2 . MULTIPLY expression2
    (43) expression2 -> expression2 . DIVIDE expression2

    SEMICOL         reduce using rule 32 (expression -> expression2 MULTIPLY expression2 .)
    COLOM           reduce using rule 32 (expression -> expression2 MULTIPLY expression2 .)
    RBRACKET        reduce using rule 32 (expression -> expression2 MULTIPLY expression2 .)
    GT              reduce using rule 32 (expression -> expression2 MULTIPLY expression2 .)
    LT              reduce using rule 32 (expression -> expression2 MULTIPLY expression2 .)
    GE              reduce using rule 32 (expression -> expression2 MULTIPLY expression2 .)
    LE              reduce using rule 32 (expression -> expression2 MULTIPLY expression2 .)
    EQ              reduce using rule 32 (expression -> expression2 MULTIPLY expression2 .)
    NE              reduce using rule 32 (expression -> expression2 MULTIPLY expression2 .)
    RPAREN          reduce using rule 32 (expression -> expression2 MULTIPLY expression2 .)
    COMMA           reduce using rule 32 (expression -> expression2 MULTIPLY expression2 .)
    AND             reduce using rule 32 (expression -> expression2 MULTIPLY expression2 .)
    OR              reduce using rule 32 (expression -> expression2 MULTIPLY expression2 .)
    PLUS            reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    MINUS           reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    MULTIPLY        reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    DIVIDE          reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)

  ! PLUS            [ shift and go to state 118 ]
  ! MINUS           [ shift and go to state 119 ]
  ! MULTIPLY        [ shift and go to state 120 ]
  ! DIVIDE          [ shift and go to state 121 ]


state 115

    (33) expression -> expression2 DIVIDE expression2 .
    (43) expression2 -> expression2 DIVIDE expression2 .
    (40) expression2 -> expression2 . PLUS expression2
    (41) expression2 -> expression2 . MINUS expression2
    (42) expression2 -> expression2 . MULTIPLY expression2
    (43) expression2 -> expression2 . DIVIDE expression2

    SEMICOL         reduce using rule 33 (expression -> expression2 DIVIDE expression2 .)
    COLOM           reduce using rule 33 (expression -> expression2 DIVIDE expression2 .)
    RBRACKET        reduce using rule 33 (expression -> expression2 DIVIDE expression2 .)
    GT              reduce using rule 33 (expression -> expression2 DIVIDE expression2 .)
    LT              reduce using rule 33 (expression -> expression2 DIVIDE expression2 .)
    GE              reduce using rule 33 (expression -> expression2 DIVIDE expression2 .)
    LE              reduce using rule 33 (expression -> expression2 DIVIDE expression2 .)
    EQ              reduce using rule 33 (expression -> expression2 DIVIDE expression2 .)
    NE              reduce using rule 33 (expression -> expression2 DIVIDE expression2 .)
    RPAREN          reduce using rule 33 (expression -> expression2 DIVIDE expression2 .)
    COMMA           reduce using rule 33 (expression -> expression2 DIVIDE expression2 .)
    AND             reduce using rule 33 (expression -> expression2 DIVIDE expression2 .)
    OR              reduce using rule 33 (expression -> expression2 DIVIDE expression2 .)
    PLUS            reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    MINUS           reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    MULTIPLY        reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    DIVIDE          reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)

  ! PLUS            [ shift and go to state 118 ]
  ! MINUS           [ shift and go to state 119 ]
  ! MULTIPLY        [ shift and go to state 120 ]
  ! DIVIDE          [ shift and go to state 121 ]


state 116

    (44) expression2 -> LPAREN expression2 . RPAREN
    (40) expression2 -> expression2 . PLUS expression2
    (41) expression2 -> expression2 . MINUS expression2
    (42) expression2 -> expression2 . MULTIPLY expression2
    (43) expression2 -> expression2 . DIVIDE expression2

    RPAREN          shift and go to state 141
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121


state 117

    (34) expression -> LPAREN expression2 RPAREN .
    (44) expression2 -> LPAREN expression2 RPAREN .

    SEMICOL         reduce using rule 34 (expression -> LPAREN expression2 RPAREN .)
    COLOM           reduce using rule 34 (expression -> LPAREN expression2 RPAREN .)
    RBRACKET        reduce using rule 34 (expression -> LPAREN expression2 RPAREN .)
    GT              reduce using rule 34 (expression -> LPAREN expression2 RPAREN .)
    LT              reduce using rule 34 (expression -> LPAREN expression2 RPAREN .)
    GE              reduce using rule 34 (expression -> LPAREN expression2 RPAREN .)
    LE              reduce using rule 34 (expression -> LPAREN expression2 RPAREN .)
    EQ              reduce using rule 34 (expression -> LPAREN expression2 RPAREN .)
    NE              reduce using rule 34 (expression -> LPAREN expression2 RPAREN .)
    RPAREN          reduce using rule 34 (expression -> LPAREN expression2 RPAREN .)
    COMMA           reduce using rule 34 (expression -> LPAREN expression2 RPAREN .)
    AND             reduce using rule 34 (expression -> LPAREN expression2 RPAREN .)
    OR              reduce using rule 34 (expression -> LPAREN expression2 RPAREN .)
    PLUS            reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    MINUS           reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    MULTIPLY        reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    DIVIDE          reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)


state 118

    (40) expression2 -> expression2 PLUS . expression2
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    LPAREN          shift and go to state 84
    IDF             shift and go to state 86
    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88

    expression2                    shift and go to state 142

state 119

    (41) expression2 -> expression2 MINUS . expression2
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    LPAREN          shift and go to state 84
    IDF             shift and go to state 86
    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88

    expression2                    shift and go to state 143

state 120

    (42) expression2 -> expression2 MULTIPLY . expression2
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    LPAREN          shift and go to state 84
    IDF             shift and go to state 86
    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88

    expression2                    shift and go to state 144

state 121

    (43) expression2 -> expression2 DIVIDE . expression2
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    LPAREN          shift and go to state 84
    IDF             shift and go to state 86
    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88

    expression2                    shift and go to state 145

state 122

    (46) expression2 -> IDF LBRACKET . expression2 RBRACKET
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    LPAREN          shift and go to state 84
    IDF             shift and go to state 86
    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88

    expression2                    shift and go to state 146

state 123

    (29) array_assignment -> IDF LBRACKET expression RBRACKET EQUALS . expression
    (30) expression -> . expression2 PLUS expression2
    (31) expression -> . expression2 MINUS expression2
    (32) expression -> . expression2 MULTIPLY expression2
    (33) expression -> . expression2 DIVIDE expression2
    (34) expression -> . LPAREN expression2 RPAREN
    (35) expression -> . IDF
    (36) expression -> . IDF LBRACKET expression2 RBRACKET
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . CHAR
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    LPAREN          shift and go to state 64
    IDF             shift and go to state 61
    INTEGER         shift and go to state 65
    FLOAT           shift and go to state 66
    CHAR            shift and go to state 67

    expression                     shift and go to state 147
    expression2                    shift and go to state 63

state 124

    (44) expression2 -> LPAREN expression2 . RPAREN
    (34) expression -> LPAREN expression2 . RPAREN
    (40) expression2 -> expression2 . PLUS expression2
    (41) expression2 -> expression2 . MINUS expression2
    (42) expression2 -> expression2 . MULTIPLY expression2
    (43) expression2 -> expression2 . DIVIDE expression2
    (30) expression -> expression2 . PLUS expression2
    (31) expression -> expression2 . MINUS expression2
    (32) expression -> expression2 . MULTIPLY expression2
    (33) expression -> expression2 . DIVIDE expression2

    RPAREN          shift and go to state 148
    PLUS            shift and go to state 126
    MINUS           shift and go to state 127
    MULTIPLY        shift and go to state 128
    DIVIDE          shift and go to state 129


state 125

    (60) condition -> LPAREN condition RPAREN .

    RPAREN          reduce using rule 60 (condition -> LPAREN condition RPAREN .)
    AND             reduce using rule 60 (condition -> LPAREN condition RPAREN .)
    OR              reduce using rule 60 (condition -> LPAREN condition RPAREN .)


state 126

    (40) expression2 -> expression2 PLUS . expression2
    (30) expression -> expression2 PLUS . expression2
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    LPAREN          shift and go to state 84
    IDF             shift and go to state 86
    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88

    expression2                    shift and go to state 149

state 127

    (41) expression2 -> expression2 MINUS . expression2
    (31) expression -> expression2 MINUS . expression2
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    LPAREN          shift and go to state 84
    IDF             shift and go to state 86
    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88

    expression2                    shift and go to state 150

state 128

    (42) expression2 -> expression2 MULTIPLY . expression2
    (32) expression -> expression2 MULTIPLY . expression2
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    LPAREN          shift and go to state 84
    IDF             shift and go to state 86
    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88

    expression2                    shift and go to state 151

state 129

    (43) expression2 -> expression2 DIVIDE . expression2
    (33) expression -> expression2 DIVIDE . expression2
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    LPAREN          shift and go to state 84
    IDF             shift and go to state 86
    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88

    expression2                    shift and go to state 152

state 130

    (46) expression2 -> IDF LBRACKET . expression2 RBRACKET
    (36) expression -> IDF LBRACKET . expression2 RBRACKET
    (40) expression2 -> . expression2 PLUS expression2
    (41) expression2 -> . expression2 MINUS expression2
    (42) expression2 -> . expression2 MULTIPLY expression2
    (43) expression2 -> . expression2 DIVIDE expression2
    (44) expression2 -> . LPAREN expression2 RPAREN
    (45) expression2 -> . IDF
    (46) expression2 -> . IDF LBRACKET expression2 RBRACKET
    (47) expression2 -> . INTEGER
    (48) expression2 -> . FLOAT

    LPAREN          shift and go to state 84
    IDF             shift and go to state 86
    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88

    expression2                    shift and go to state 153

state 131

    (49) if_statement -> IF LPAREN condition RPAREN LBRACE . instructions RBRACE
    (50) if_statement -> IF LPAREN condition RPAREN LBRACE . instructions RBRACE ELSE LBRACE instructions RBRACE
    (20) instructions -> . instructions instruction
    (21) instructions -> . instruction
    (22) instructions -> . empty
    (23) instruction -> . assignment SEMICOL
    (24) instruction -> . array_assignment SEMICOL
    (25) instruction -> . if_statement
    (26) instruction -> . for_loop
    (27) instruction -> . io_statement SEMICOL
    (73) empty -> .
    (28) assignment -> . IDF EQUALS expression
    (29) array_assignment -> . IDF LBRACKET expression RBRACKET EQUALS expression
    (49) if_statement -> . IF LPAREN condition RPAREN LBRACE instructions RBRACE
    (50) if_statement -> . IF LPAREN condition RPAREN LBRACE instructions RBRACE ELSE LBRACE instructions RBRACE
    (51) for_loop -> . FOR LPAREN assignment COLOM for_pas COLOM for_condition RPAREN LBRACE instructions RBRACE
    (67) io_statement -> . READ LPAREN IDF RPAREN
    (68) io_statement -> . WRITE LPAREN write_list RPAREN

  ! shift/reduce conflict for IDF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
    RBRACE          reduce using rule 73 (empty -> .)
    IDF             shift and go to state 42
    IF              shift and go to state 43
    FOR             shift and go to state 44
    READ            shift and go to state 45
    WRITE           shift and go to state 46

  ! IDF             [ reduce using rule 73 (empty -> .) ]
  ! IF              [ reduce using rule 73 (empty -> .) ]
  ! FOR             [ reduce using rule 73 (empty -> .) ]
  ! READ            [ reduce using rule 73 (empty -> .) ]
  ! WRITE           [ reduce using rule 73 (empty -> .) ]

    instructions                   shift and go to state 154
    instruction                    shift and go to state 35
    empty                          shift and go to state 36
    assignment                     shift and go to state 37
    array_assignment               shift and go to state 38
    if_statement                   shift and go to state 39
    for_loop                       shift and go to state 40
    io_statement                   shift and go to state 41

state 132

    (57) condition -> condition AND condition .
    (57) condition -> condition . AND condition
    (58) condition -> condition . OR condition

    RPAREN          reduce using rule 57 (condition -> condition AND condition .)
    AND             reduce using rule 57 (condition -> condition AND condition .)
    OR              reduce using rule 57 (condition -> condition AND condition .)

  ! AND             [ shift and go to state 97 ]
  ! OR              [ shift and go to state 98 ]


state 133

    (58) condition -> condition OR condition .
    (57) condition -> condition . AND condition
    (58) condition -> condition . OR condition

    RPAREN          reduce using rule 58 (condition -> condition OR condition .)
    OR              reduce using rule 58 (condition -> condition OR condition .)
    AND             shift and go to state 97

  ! AND             [ reduce using rule 58 (condition -> condition OR condition .) ]
  ! OR              [ shift and go to state 98 ]


state 134

    (56) condition -> expression comparison_op expression .

    RPAREN          reduce using rule 56 (condition -> expression comparison_op expression .)
    AND             reduce using rule 56 (condition -> expression comparison_op expression .)
    OR              reduce using rule 56 (condition -> expression comparison_op expression .)


state 135

    (51) for_loop -> FOR LPAREN assignment COLOM for_pas . COLOM for_condition RPAREN LBRACE instructions RBRACE

    COLOM           shift and go to state 155


state 136

    (52) for_pas -> IDF .

    COLOM           reduce using rule 52 (for_pas -> IDF .)


state 137

    (53) for_pas -> INTEGER .

    COLOM           reduce using rule 53 (for_pas -> INTEGER .)


state 138

    (69) write_list -> write_list COMMA expression .

    RPAREN          reduce using rule 69 (write_list -> write_list COMMA expression .)
    COMMA           reduce using rule 69 (write_list -> write_list COMMA expression .)


state 139

    (72) write_list -> write_list COMMA STRING .

    RPAREN          reduce using rule 72 (write_list -> write_list COMMA STRING .)
    COMMA           reduce using rule 72 (write_list -> write_list COMMA STRING .)


state 140

    (36) expression -> IDF LBRACKET expression2 RBRACKET .
    (46) expression2 -> IDF LBRACKET expression2 RBRACKET .

    SEMICOL         reduce using rule 36 (expression -> IDF LBRACKET expression2 RBRACKET .)
    COLOM           reduce using rule 36 (expression -> IDF LBRACKET expression2 RBRACKET .)
    RBRACKET        reduce using rule 36 (expression -> IDF LBRACKET expression2 RBRACKET .)
    GT              reduce using rule 36 (expression -> IDF LBRACKET expression2 RBRACKET .)
    LT              reduce using rule 36 (expression -> IDF LBRACKET expression2 RBRACKET .)
    GE              reduce using rule 36 (expression -> IDF LBRACKET expression2 RBRACKET .)
    LE              reduce using rule 36 (expression -> IDF LBRACKET expression2 RBRACKET .)
    EQ              reduce using rule 36 (expression -> IDF LBRACKET expression2 RBRACKET .)
    NE              reduce using rule 36 (expression -> IDF LBRACKET expression2 RBRACKET .)
    RPAREN          reduce using rule 36 (expression -> IDF LBRACKET expression2 RBRACKET .)
    COMMA           reduce using rule 36 (expression -> IDF LBRACKET expression2 RBRACKET .)
    AND             reduce using rule 36 (expression -> IDF LBRACKET expression2 RBRACKET .)
    OR              reduce using rule 36 (expression -> IDF LBRACKET expression2 RBRACKET .)
    PLUS            reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    MINUS           reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    MULTIPLY        reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    DIVIDE          reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)


state 141

    (44) expression2 -> LPAREN expression2 RPAREN .

    RPAREN          reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    PLUS            reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    MINUS           reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    MULTIPLY        reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    DIVIDE          reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    RBRACKET        reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    SEMICOL         reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    COLOM           reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    GT              reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    LT              reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    GE              reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    LE              reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    EQ              reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    NE              reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    COMMA           reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    AND             reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    OR              reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)


state 142

    (40) expression2 -> expression2 PLUS expression2 .
    (40) expression2 -> expression2 . PLUS expression2
    (41) expression2 -> expression2 . MINUS expression2
    (42) expression2 -> expression2 . MULTIPLY expression2
    (43) expression2 -> expression2 . DIVIDE expression2

    RPAREN          reduce using rule 40 (expression2 -> expression2 PLUS expression2 .)
    PLUS            reduce using rule 40 (expression2 -> expression2 PLUS expression2 .)
    MINUS           reduce using rule 40 (expression2 -> expression2 PLUS expression2 .)
    RBRACKET        reduce using rule 40 (expression2 -> expression2 PLUS expression2 .)
    SEMICOL         reduce using rule 40 (expression2 -> expression2 PLUS expression2 .)
    COLOM           reduce using rule 40 (expression2 -> expression2 PLUS expression2 .)
    GT              reduce using rule 40 (expression2 -> expression2 PLUS expression2 .)
    LT              reduce using rule 40 (expression2 -> expression2 PLUS expression2 .)
    GE              reduce using rule 40 (expression2 -> expression2 PLUS expression2 .)
    LE              reduce using rule 40 (expression2 -> expression2 PLUS expression2 .)
    EQ              reduce using rule 40 (expression2 -> expression2 PLUS expression2 .)
    NE              reduce using rule 40 (expression2 -> expression2 PLUS expression2 .)
    COMMA           reduce using rule 40 (expression2 -> expression2 PLUS expression2 .)
    AND             reduce using rule 40 (expression2 -> expression2 PLUS expression2 .)
    OR              reduce using rule 40 (expression2 -> expression2 PLUS expression2 .)
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121

  ! MULTIPLY        [ reduce using rule 40 (expression2 -> expression2 PLUS expression2 .) ]
  ! DIVIDE          [ reduce using rule 40 (expression2 -> expression2 PLUS expression2 .) ]
  ! PLUS            [ shift and go to state 118 ]
  ! MINUS           [ shift and go to state 119 ]


state 143

    (41) expression2 -> expression2 MINUS expression2 .
    (40) expression2 -> expression2 . PLUS expression2
    (41) expression2 -> expression2 . MINUS expression2
    (42) expression2 -> expression2 . MULTIPLY expression2
    (43) expression2 -> expression2 . DIVIDE expression2

    RPAREN          reduce using rule 41 (expression2 -> expression2 MINUS expression2 .)
    PLUS            reduce using rule 41 (expression2 -> expression2 MINUS expression2 .)
    MINUS           reduce using rule 41 (expression2 -> expression2 MINUS expression2 .)
    RBRACKET        reduce using rule 41 (expression2 -> expression2 MINUS expression2 .)
    SEMICOL         reduce using rule 41 (expression2 -> expression2 MINUS expression2 .)
    COLOM           reduce using rule 41 (expression2 -> expression2 MINUS expression2 .)
    GT              reduce using rule 41 (expression2 -> expression2 MINUS expression2 .)
    LT              reduce using rule 41 (expression2 -> expression2 MINUS expression2 .)
    GE              reduce using rule 41 (expression2 -> expression2 MINUS expression2 .)
    LE              reduce using rule 41 (expression2 -> expression2 MINUS expression2 .)
    EQ              reduce using rule 41 (expression2 -> expression2 MINUS expression2 .)
    NE              reduce using rule 41 (expression2 -> expression2 MINUS expression2 .)
    COMMA           reduce using rule 41 (expression2 -> expression2 MINUS expression2 .)
    AND             reduce using rule 41 (expression2 -> expression2 MINUS expression2 .)
    OR              reduce using rule 41 (expression2 -> expression2 MINUS expression2 .)
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121

  ! MULTIPLY        [ reduce using rule 41 (expression2 -> expression2 MINUS expression2 .) ]
  ! DIVIDE          [ reduce using rule 41 (expression2 -> expression2 MINUS expression2 .) ]
  ! PLUS            [ shift and go to state 118 ]
  ! MINUS           [ shift and go to state 119 ]


state 144

    (42) expression2 -> expression2 MULTIPLY expression2 .
    (40) expression2 -> expression2 . PLUS expression2
    (41) expression2 -> expression2 . MINUS expression2
    (42) expression2 -> expression2 . MULTIPLY expression2
    (43) expression2 -> expression2 . DIVIDE expression2

    RPAREN          reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    PLUS            reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    MINUS           reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    MULTIPLY        reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    DIVIDE          reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    RBRACKET        reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    SEMICOL         reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    COLOM           reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    GT              reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    LT              reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    GE              reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    LE              reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    EQ              reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    NE              reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    COMMA           reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    AND             reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    OR              reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)

  ! PLUS            [ shift and go to state 118 ]
  ! MINUS           [ shift and go to state 119 ]
  ! MULTIPLY        [ shift and go to state 120 ]
  ! DIVIDE          [ shift and go to state 121 ]


state 145

    (43) expression2 -> expression2 DIVIDE expression2 .
    (40) expression2 -> expression2 . PLUS expression2
    (41) expression2 -> expression2 . MINUS expression2
    (42) expression2 -> expression2 . MULTIPLY expression2
    (43) expression2 -> expression2 . DIVIDE expression2

    RPAREN          reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    PLUS            reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    MINUS           reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    MULTIPLY        reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    DIVIDE          reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    RBRACKET        reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    SEMICOL         reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    COLOM           reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    GT              reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    LT              reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    GE              reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    LE              reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    EQ              reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    NE              reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    COMMA           reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    AND             reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    OR              reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)

  ! PLUS            [ shift and go to state 118 ]
  ! MINUS           [ shift and go to state 119 ]
  ! MULTIPLY        [ shift and go to state 120 ]
  ! DIVIDE          [ shift and go to state 121 ]


state 146

    (46) expression2 -> IDF LBRACKET expression2 . RBRACKET
    (40) expression2 -> expression2 . PLUS expression2
    (41) expression2 -> expression2 . MINUS expression2
    (42) expression2 -> expression2 . MULTIPLY expression2
    (43) expression2 -> expression2 . DIVIDE expression2

    RBRACKET        shift and go to state 156
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121


state 147

    (29) array_assignment -> IDF LBRACKET expression RBRACKET EQUALS expression .

    SEMICOL         reduce using rule 29 (array_assignment -> IDF LBRACKET expression RBRACKET EQUALS expression .)


state 148

    (44) expression2 -> LPAREN expression2 RPAREN .
    (34) expression -> LPAREN expression2 RPAREN .

    RPAREN          reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    PLUS            reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    MINUS           reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    MULTIPLY        reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    DIVIDE          reduce using rule 44 (expression2 -> LPAREN expression2 RPAREN .)
    GT              reduce using rule 34 (expression -> LPAREN expression2 RPAREN .)
    LT              reduce using rule 34 (expression -> LPAREN expression2 RPAREN .)
    GE              reduce using rule 34 (expression -> LPAREN expression2 RPAREN .)
    LE              reduce using rule 34 (expression -> LPAREN expression2 RPAREN .)
    EQ              reduce using rule 34 (expression -> LPAREN expression2 RPAREN .)
    NE              reduce using rule 34 (expression -> LPAREN expression2 RPAREN .)


state 149

    (40) expression2 -> expression2 PLUS expression2 .
    (30) expression -> expression2 PLUS expression2 .
    (40) expression2 -> expression2 . PLUS expression2
    (41) expression2 -> expression2 . MINUS expression2
    (42) expression2 -> expression2 . MULTIPLY expression2
    (43) expression2 -> expression2 . DIVIDE expression2

    RPAREN          reduce using rule 40 (expression2 -> expression2 PLUS expression2 .)
    PLUS            reduce using rule 40 (expression2 -> expression2 PLUS expression2 .)
    MINUS           reduce using rule 40 (expression2 -> expression2 PLUS expression2 .)
    GT              reduce using rule 30 (expression -> expression2 PLUS expression2 .)
    LT              reduce using rule 30 (expression -> expression2 PLUS expression2 .)
    GE              reduce using rule 30 (expression -> expression2 PLUS expression2 .)
    LE              reduce using rule 30 (expression -> expression2 PLUS expression2 .)
    EQ              reduce using rule 30 (expression -> expression2 PLUS expression2 .)
    NE              reduce using rule 30 (expression -> expression2 PLUS expression2 .)
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121

  ! MULTIPLY        [ reduce using rule 40 (expression2 -> expression2 PLUS expression2 .) ]
  ! DIVIDE          [ reduce using rule 40 (expression2 -> expression2 PLUS expression2 .) ]
  ! PLUS            [ shift and go to state 118 ]
  ! MINUS           [ shift and go to state 119 ]


state 150

    (41) expression2 -> expression2 MINUS expression2 .
    (31) expression -> expression2 MINUS expression2 .
    (40) expression2 -> expression2 . PLUS expression2
    (41) expression2 -> expression2 . MINUS expression2
    (42) expression2 -> expression2 . MULTIPLY expression2
    (43) expression2 -> expression2 . DIVIDE expression2

    RPAREN          reduce using rule 41 (expression2 -> expression2 MINUS expression2 .)
    PLUS            reduce using rule 41 (expression2 -> expression2 MINUS expression2 .)
    MINUS           reduce using rule 41 (expression2 -> expression2 MINUS expression2 .)
    GT              reduce using rule 31 (expression -> expression2 MINUS expression2 .)
    LT              reduce using rule 31 (expression -> expression2 MINUS expression2 .)
    GE              reduce using rule 31 (expression -> expression2 MINUS expression2 .)
    LE              reduce using rule 31 (expression -> expression2 MINUS expression2 .)
    EQ              reduce using rule 31 (expression -> expression2 MINUS expression2 .)
    NE              reduce using rule 31 (expression -> expression2 MINUS expression2 .)
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121

  ! MULTIPLY        [ reduce using rule 41 (expression2 -> expression2 MINUS expression2 .) ]
  ! DIVIDE          [ reduce using rule 41 (expression2 -> expression2 MINUS expression2 .) ]
  ! PLUS            [ shift and go to state 118 ]
  ! MINUS           [ shift and go to state 119 ]


state 151

    (42) expression2 -> expression2 MULTIPLY expression2 .
    (32) expression -> expression2 MULTIPLY expression2 .
    (40) expression2 -> expression2 . PLUS expression2
    (41) expression2 -> expression2 . MINUS expression2
    (42) expression2 -> expression2 . MULTIPLY expression2
    (43) expression2 -> expression2 . DIVIDE expression2

    RPAREN          reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    PLUS            reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    MINUS           reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    MULTIPLY        reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    DIVIDE          reduce using rule 42 (expression2 -> expression2 MULTIPLY expression2 .)
    GT              reduce using rule 32 (expression -> expression2 MULTIPLY expression2 .)
    LT              reduce using rule 32 (expression -> expression2 MULTIPLY expression2 .)
    GE              reduce using rule 32 (expression -> expression2 MULTIPLY expression2 .)
    LE              reduce using rule 32 (expression -> expression2 MULTIPLY expression2 .)
    EQ              reduce using rule 32 (expression -> expression2 MULTIPLY expression2 .)
    NE              reduce using rule 32 (expression -> expression2 MULTIPLY expression2 .)

  ! PLUS            [ shift and go to state 118 ]
  ! MINUS           [ shift and go to state 119 ]
  ! MULTIPLY        [ shift and go to state 120 ]
  ! DIVIDE          [ shift and go to state 121 ]


state 152

    (43) expression2 -> expression2 DIVIDE expression2 .
    (33) expression -> expression2 DIVIDE expression2 .
    (40) expression2 -> expression2 . PLUS expression2
    (41) expression2 -> expression2 . MINUS expression2
    (42) expression2 -> expression2 . MULTIPLY expression2
    (43) expression2 -> expression2 . DIVIDE expression2

    RPAREN          reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    PLUS            reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    MINUS           reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    MULTIPLY        reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    DIVIDE          reduce using rule 43 (expression2 -> expression2 DIVIDE expression2 .)
    GT              reduce using rule 33 (expression -> expression2 DIVIDE expression2 .)
    LT              reduce using rule 33 (expression -> expression2 DIVIDE expression2 .)
    GE              reduce using rule 33 (expression -> expression2 DIVIDE expression2 .)
    LE              reduce using rule 33 (expression -> expression2 DIVIDE expression2 .)
    EQ              reduce using rule 33 (expression -> expression2 DIVIDE expression2 .)
    NE              reduce using rule 33 (expression -> expression2 DIVIDE expression2 .)

  ! PLUS            [ shift and go to state 118 ]
  ! MINUS           [ shift and go to state 119 ]
  ! MULTIPLY        [ shift and go to state 120 ]
  ! DIVIDE          [ shift and go to state 121 ]


state 153

    (46) expression2 -> IDF LBRACKET expression2 . RBRACKET
    (36) expression -> IDF LBRACKET expression2 . RBRACKET
    (40) expression2 -> expression2 . PLUS expression2
    (41) expression2 -> expression2 . MINUS expression2
    (42) expression2 -> expression2 . MULTIPLY expression2
    (43) expression2 -> expression2 . DIVIDE expression2

    RBRACKET        shift and go to state 157
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121


state 154

    (49) if_statement -> IF LPAREN condition RPAREN LBRACE instructions . RBRACE
    (50) if_statement -> IF LPAREN condition RPAREN LBRACE instructions . RBRACE ELSE LBRACE instructions RBRACE
    (20) instructions -> instructions . instruction
    (23) instruction -> . assignment SEMICOL
    (24) instruction -> . array_assignment SEMICOL
    (25) instruction -> . if_statement
    (26) instruction -> . for_loop
    (27) instruction -> . io_statement SEMICOL
    (28) assignment -> . IDF EQUALS expression
    (29) array_assignment -> . IDF LBRACKET expression RBRACKET EQUALS expression
    (49) if_statement -> . IF LPAREN condition RPAREN LBRACE instructions RBRACE
    (50) if_statement -> . IF LPAREN condition RPAREN LBRACE instructions RBRACE ELSE LBRACE instructions RBRACE
    (51) for_loop -> . FOR LPAREN assignment COLOM for_pas COLOM for_condition RPAREN LBRACE instructions RBRACE
    (67) io_statement -> . READ LPAREN IDF RPAREN
    (68) io_statement -> . WRITE LPAREN write_list RPAREN

    RBRACE          shift and go to state 158
    IDF             shift and go to state 42
    IF              shift and go to state 43
    FOR             shift and go to state 44
    READ            shift and go to state 45
    WRITE           shift and go to state 46

    instruction                    shift and go to state 50
    assignment                     shift and go to state 37
    array_assignment               shift and go to state 38
    if_statement                   shift and go to state 39
    for_loop                       shift and go to state 40
    io_statement                   shift and go to state 41

state 155

    (51) for_loop -> FOR LPAREN assignment COLOM for_pas COLOM . for_condition RPAREN LBRACE instructions RBRACE
    (54) for_condition -> . IDF
    (55) for_condition -> . INTEGER

    IDF             shift and go to state 160
    INTEGER         shift and go to state 161

    for_condition                  shift and go to state 159

state 156

    (46) expression2 -> IDF LBRACKET expression2 RBRACKET .

    RPAREN          reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    PLUS            reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    MINUS           reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    MULTIPLY        reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    DIVIDE          reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    RBRACKET        reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    SEMICOL         reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    COLOM           reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    GT              reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    LT              reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    GE              reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    LE              reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    EQ              reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    NE              reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    COMMA           reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    AND             reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    OR              reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)


state 157

    (46) expression2 -> IDF LBRACKET expression2 RBRACKET .
    (36) expression -> IDF LBRACKET expression2 RBRACKET .

    RPAREN          reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    PLUS            reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    MINUS           reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    MULTIPLY        reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    DIVIDE          reduce using rule 46 (expression2 -> IDF LBRACKET expression2 RBRACKET .)
    GT              reduce using rule 36 (expression -> IDF LBRACKET expression2 RBRACKET .)
    LT              reduce using rule 36 (expression -> IDF LBRACKET expression2 RBRACKET .)
    GE              reduce using rule 36 (expression -> IDF LBRACKET expression2 RBRACKET .)
    LE              reduce using rule 36 (expression -> IDF LBRACKET expression2 RBRACKET .)
    EQ              reduce using rule 36 (expression -> IDF LBRACKET expression2 RBRACKET .)
    NE              reduce using rule 36 (expression -> IDF LBRACKET expression2 RBRACKET .)


state 158

    (49) if_statement -> IF LPAREN condition RPAREN LBRACE instructions RBRACE .
    (50) if_statement -> IF LPAREN condition RPAREN LBRACE instructions RBRACE . ELSE LBRACE instructions RBRACE

    RBRACE          reduce using rule 49 (if_statement -> IF LPAREN condition RPAREN LBRACE instructions RBRACE .)
    IDF             reduce using rule 49 (if_statement -> IF LPAREN condition RPAREN LBRACE instructions RBRACE .)
    IF              reduce using rule 49 (if_statement -> IF LPAREN condition RPAREN LBRACE instructions RBRACE .)
    FOR             reduce using rule 49 (if_statement -> IF LPAREN condition RPAREN LBRACE instructions RBRACE .)
    READ            reduce using rule 49 (if_statement -> IF LPAREN condition RPAREN LBRACE instructions RBRACE .)
    WRITE           reduce using rule 49 (if_statement -> IF LPAREN condition RPAREN LBRACE instructions RBRACE .)
    ELSE            shift and go to state 162


state 159

    (51) for_loop -> FOR LPAREN assignment COLOM for_pas COLOM for_condition . RPAREN LBRACE instructions RBRACE

    RPAREN          shift and go to state 163


state 160

    (54) for_condition -> IDF .

    RPAREN          reduce using rule 54 (for_condition -> IDF .)


state 161

    (55) for_condition -> INTEGER .

    RPAREN          reduce using rule 55 (for_condition -> INTEGER .)


state 162

    (50) if_statement -> IF LPAREN condition RPAREN LBRACE instructions RBRACE ELSE . LBRACE instructions RBRACE

    LBRACE          shift and go to state 164


state 163

    (51) for_loop -> FOR LPAREN assignment COLOM for_pas COLOM for_condition RPAREN . LBRACE instructions RBRACE

    LBRACE          shift and go to state 165


state 164

    (50) if_statement -> IF LPAREN condition RPAREN LBRACE instructions RBRACE ELSE LBRACE . instructions RBRACE
    (20) instructions -> . instructions instruction
    (21) instructions -> . instruction
    (22) instructions -> . empty
    (23) instruction -> . assignment SEMICOL
    (24) instruction -> . array_assignment SEMICOL
    (25) instruction -> . if_statement
    (26) instruction -> . for_loop
    (27) instruction -> . io_statement SEMICOL
    (73) empty -> .
    (28) assignment -> . IDF EQUALS expression
    (29) array_assignment -> . IDF LBRACKET expression RBRACKET EQUALS expression
    (49) if_statement -> . IF LPAREN condition RPAREN LBRACE instructions RBRACE
    (50) if_statement -> . IF LPAREN condition RPAREN LBRACE instructions RBRACE ELSE LBRACE instructions RBRACE
    (51) for_loop -> . FOR LPAREN assignment COLOM for_pas COLOM for_condition RPAREN LBRACE instructions RBRACE
    (67) io_statement -> . READ LPAREN IDF RPAREN
    (68) io_statement -> . WRITE LPAREN write_list RPAREN

  ! shift/reduce conflict for IDF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
    RBRACE          reduce using rule 73 (empty -> .)
    IDF             shift and go to state 42
    IF              shift and go to state 43
    FOR             shift and go to state 44
    READ            shift and go to state 45
    WRITE           shift and go to state 46

  ! IDF             [ reduce using rule 73 (empty -> .) ]
  ! IF              [ reduce using rule 73 (empty -> .) ]
  ! FOR             [ reduce using rule 73 (empty -> .) ]
  ! READ            [ reduce using rule 73 (empty -> .) ]
  ! WRITE           [ reduce using rule 73 (empty -> .) ]

    instructions                   shift and go to state 166
    instruction                    shift and go to state 35
    empty                          shift and go to state 36
    assignment                     shift and go to state 37
    array_assignment               shift and go to state 38
    if_statement                   shift and go to state 39
    for_loop                       shift and go to state 40
    io_statement                   shift and go to state 41

state 165

    (51) for_loop -> FOR LPAREN assignment COLOM for_pas COLOM for_condition RPAREN LBRACE . instructions RBRACE
    (20) instructions -> . instructions instruction
    (21) instructions -> . instruction
    (22) instructions -> . empty
    (23) instruction -> . assignment SEMICOL
    (24) instruction -> . array_assignment SEMICOL
    (25) instruction -> . if_statement
    (26) instruction -> . for_loop
    (27) instruction -> . io_statement SEMICOL
    (73) empty -> .
    (28) assignment -> . IDF EQUALS expression
    (29) array_assignment -> . IDF LBRACKET expression RBRACKET EQUALS expression
    (49) if_statement -> . IF LPAREN condition RPAREN LBRACE instructions RBRACE
    (50) if_statement -> . IF LPAREN condition RPAREN LBRACE instructions RBRACE ELSE LBRACE instructions RBRACE
    (51) for_loop -> . FOR LPAREN assignment COLOM for_pas COLOM for_condition RPAREN LBRACE instructions RBRACE
    (67) io_statement -> . READ LPAREN IDF RPAREN
    (68) io_statement -> . WRITE LPAREN write_list RPAREN

  ! shift/reduce conflict for IDF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
    RBRACE          reduce using rule 73 (empty -> .)
    IDF             shift and go to state 42
    IF              shift and go to state 43
    FOR             shift and go to state 44
    READ            shift and go to state 45
    WRITE           shift and go to state 46

  ! IDF             [ reduce using rule 73 (empty -> .) ]
  ! IF              [ reduce using rule 73 (empty -> .) ]
  ! FOR             [ reduce using rule 73 (empty -> .) ]
  ! READ            [ reduce using rule 73 (empty -> .) ]
  ! WRITE           [ reduce using rule 73 (empty -> .) ]

    assignment                     shift and go to state 37
    instructions                   shift and go to state 167
    instruction                    shift and go to state 35
    empty                          shift and go to state 36
    array_assignment               shift and go to state 38
    if_statement                   shift and go to state 39
    for_loop                       shift and go to state 40
    io_statement                   shift and go to state 41

state 166

    (50) if_statement -> IF LPAREN condition RPAREN LBRACE instructions RBRACE ELSE LBRACE instructions . RBRACE
    (20) instructions -> instructions . instruction
    (23) instruction -> . assignment SEMICOL
    (24) instruction -> . array_assignment SEMICOL
    (25) instruction -> . if_statement
    (26) instruction -> . for_loop
    (27) instruction -> . io_statement SEMICOL
    (28) assignment -> . IDF EQUALS expression
    (29) array_assignment -> . IDF LBRACKET expression RBRACKET EQUALS expression
    (49) if_statement -> . IF LPAREN condition RPAREN LBRACE instructions RBRACE
    (50) if_statement -> . IF LPAREN condition RPAREN LBRACE instructions RBRACE ELSE LBRACE instructions RBRACE
    (51) for_loop -> . FOR LPAREN assignment COLOM for_pas COLOM for_condition RPAREN LBRACE instructions RBRACE
    (67) io_statement -> . READ LPAREN IDF RPAREN
    (68) io_statement -> . WRITE LPAREN write_list RPAREN

    RBRACE          shift and go to state 168
    IDF             shift and go to state 42
    IF              shift and go to state 43
    FOR             shift and go to state 44
    READ            shift and go to state 45
    WRITE           shift and go to state 46

    instruction                    shift and go to state 50
    assignment                     shift and go to state 37
    array_assignment               shift and go to state 38
    if_statement                   shift and go to state 39
    for_loop                       shift and go to state 40
    io_statement                   shift and go to state 41

state 167

    (51) for_loop -> FOR LPAREN assignment COLOM for_pas COLOM for_condition RPAREN LBRACE instructions . RBRACE
    (20) instructions -> instructions . instruction
    (23) instruction -> . assignment SEMICOL
    (24) instruction -> . array_assignment SEMICOL
    (25) instruction -> . if_statement
    (26) instruction -> . for_loop
    (27) instruction -> . io_statement SEMICOL
    (28) assignment -> . IDF EQUALS expression
    (29) array_assignment -> . IDF LBRACKET expression RBRACKET EQUALS expression
    (49) if_statement -> . IF LPAREN condition RPAREN LBRACE instructions RBRACE
    (50) if_statement -> . IF LPAREN condition RPAREN LBRACE instructions RBRACE ELSE LBRACE instructions RBRACE
    (51) for_loop -> . FOR LPAREN assignment COLOM for_pas COLOM for_condition RPAREN LBRACE instructions RBRACE
    (67) io_statement -> . READ LPAREN IDF RPAREN
    (68) io_statement -> . WRITE LPAREN write_list RPAREN

    RBRACE          shift and go to state 169
    IDF             shift and go to state 42
    IF              shift and go to state 43
    FOR             shift and go to state 44
    READ            shift and go to state 45
    WRITE           shift and go to state 46

    assignment                     shift and go to state 37
    instruction                    shift and go to state 50
    array_assignment               shift and go to state 38
    if_statement                   shift and go to state 39
    for_loop                       shift and go to state 40
    io_statement                   shift and go to state 41

state 168

    (50) if_statement -> IF LPAREN condition RPAREN LBRACE instructions RBRACE ELSE LBRACE instructions RBRACE .

    RBRACE          reduce using rule 50 (if_statement -> IF LPAREN condition RPAREN LBRACE instructions RBRACE ELSE LBRACE instructions RBRACE .)
    IDF             reduce using rule 50 (if_statement -> IF LPAREN condition RPAREN LBRACE instructions RBRACE ELSE LBRACE instructions RBRACE .)
    IF              reduce using rule 50 (if_statement -> IF LPAREN condition RPAREN LBRACE instructions RBRACE ELSE LBRACE instructions RBRACE .)
    FOR             reduce using rule 50 (if_statement -> IF LPAREN condition RPAREN LBRACE instructions RBRACE ELSE LBRACE instructions RBRACE .)
    READ            reduce using rule 50 (if_statement -> IF LPAREN condition RPAREN LBRACE instructions RBRACE ELSE LBRACE instructions RBRACE .)
    WRITE           reduce using rule 50 (if_statement -> IF LPAREN condition RPAREN LBRACE instructions RBRACE ELSE LBRACE instructions RBRACE .)


state 169

    (51) for_loop -> FOR LPAREN assignment COLOM for_pas COLOM for_condition RPAREN LBRACE instructions RBRACE .

    RBRACE          reduce using rule 51 (for_loop -> FOR LPAREN assignment COLOM for_pas COLOM for_condition RPAREN LBRACE instructions RBRACE .)
    IDF             reduce using rule 51 (for_loop -> FOR LPAREN assignment COLOM for_pas COLOM for_condition RPAREN LBRACE instructions RBRACE .)
    IF              reduce using rule 51 (for_loop -> FOR LPAREN assignment COLOM for_pas COLOM for_condition RPAREN LBRACE instructions RBRACE .)
    FOR             reduce using rule 51 (for_loop -> FOR LPAREN assignment COLOM for_pas COLOM for_condition RPAREN LBRACE instructions RBRACE .)
    READ            reduce using rule 51 (for_loop -> FOR LPAREN assignment COLOM for_pas COLOM for_condition RPAREN LBRACE instructions RBRACE .)
    WRITE           reduce using rule 51 (for_loop -> FOR LPAREN assignment COLOM for_pas COLOM for_condition RPAREN LBRACE instructions RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for CONST in state 3 resolved as shift
WARNING: shift/reduce conflict for TYPE_INTEGER in state 3 resolved as shift
WARNING: shift/reduce conflict for TYPE_FLOAT in state 3 resolved as shift
WARNING: shift/reduce conflict for TYPE_CHAR in state 3 resolved as shift
WARNING: shift/reduce conflict for IDF in state 26 resolved as shift
WARNING: shift/reduce conflict for IF in state 26 resolved as shift
WARNING: shift/reduce conflict for FOR in state 26 resolved as shift
WARNING: shift/reduce conflict for READ in state 26 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 26 resolved as shift
WARNING: shift/reduce conflict for IDF in state 131 resolved as shift
WARNING: shift/reduce conflict for IF in state 131 resolved as shift
WARNING: shift/reduce conflict for FOR in state 131 resolved as shift
WARNING: shift/reduce conflict for READ in state 131 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 131 resolved as shift
WARNING: shift/reduce conflict for IDF in state 164 resolved as shift
WARNING: shift/reduce conflict for IF in state 164 resolved as shift
WARNING: shift/reduce conflict for FOR in state 164 resolved as shift
WARNING: shift/reduce conflict for READ in state 164 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 164 resolved as shift
WARNING: shift/reduce conflict for IDF in state 165 resolved as shift
WARNING: shift/reduce conflict for IF in state 165 resolved as shift
WARNING: shift/reduce conflict for FOR in state 165 resolved as shift
WARNING: shift/reduce conflict for READ in state 165 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 165 resolved as shift
